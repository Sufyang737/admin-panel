
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Persona
 * 
 */
export type Persona = $Result.DefaultSelection<Prisma.$PersonaPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model Ciudad
 * 
 */
export type Ciudad = $Result.DefaultSelection<Prisma.$CiudadPayload>
/**
 * Model Evento
 * 
 */
export type Evento = $Result.DefaultSelection<Prisma.$EventoPayload>
/**
 * Model TipoEvento
 * 
 */
export type TipoEvento = $Result.DefaultSelection<Prisma.$TipoEventoPayload>
/**
 * Model Empleada
 * 
 */
export type Empleada = $Result.DefaultSelection<Prisma.$EmpleadaPayload>
/**
 * Model EmpleadaRol
 * 
 */
export type EmpleadaRol = $Result.DefaultSelection<Prisma.$EmpleadaRolPayload>
/**
 * Model Movimiento
 * 
 */
export type Movimiento = $Result.DefaultSelection<Prisma.$MovimientoPayload>
/**
 * Model CatMov
 * 
 */
export type CatMov = $Result.DefaultSelection<Prisma.$CatMovPayload>
/**
 * Model SubcatMovimiento
 * 
 */
export type SubcatMovimiento = $Result.DefaultSelection<Prisma.$SubcatMovimientoPayload>
/**
 * Model DetMov
 * 
 */
export type DetMov = $Result.DefaultSelection<Prisma.$DetMovPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  DEV: 'DEV',
  CONTABLE: 'CONTABLE',
  DEFAULT: 'DEFAULT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const RolEmpleada: {
  SOCIA: 'SOCIA',
  PLANNER: 'PLANNER',
  STAFF: 'STAFF',
  ADMINISTRATIVA: 'ADMINISTRATIVA'
};

export type RolEmpleada = (typeof RolEmpleada)[keyof typeof RolEmpleada]


export const Moneda: {
  USD: 'USD',
  ARS: 'ARS'
};

export type Moneda = (typeof Moneda)[keyof typeof Moneda]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type RolEmpleada = $Enums.RolEmpleada

export const RolEmpleada: typeof $Enums.RolEmpleada

export type Moneda = $Enums.Moneda

export const Moneda: typeof $Enums.Moneda

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.persona`: Exposes CRUD operations for the **Persona** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personas
    * const personas = await prisma.persona.findMany()
    * ```
    */
  get persona(): Prisma.PersonaDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.ciudad`: Exposes CRUD operations for the **Ciudad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ciudads
    * const ciudads = await prisma.ciudad.findMany()
    * ```
    */
  get ciudad(): Prisma.CiudadDelegate<ExtArgs>;

  /**
   * `prisma.evento`: Exposes CRUD operations for the **Evento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventos
    * const eventos = await prisma.evento.findMany()
    * ```
    */
  get evento(): Prisma.EventoDelegate<ExtArgs>;

  /**
   * `prisma.tipoEvento`: Exposes CRUD operations for the **TipoEvento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoEventos
    * const tipoEventos = await prisma.tipoEvento.findMany()
    * ```
    */
  get tipoEvento(): Prisma.TipoEventoDelegate<ExtArgs>;

  /**
   * `prisma.empleada`: Exposes CRUD operations for the **Empleada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleadas
    * const empleadas = await prisma.empleada.findMany()
    * ```
    */
  get empleada(): Prisma.EmpleadaDelegate<ExtArgs>;

  /**
   * `prisma.empleadaRol`: Exposes CRUD operations for the **EmpleadaRol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmpleadaRols
    * const empleadaRols = await prisma.empleadaRol.findMany()
    * ```
    */
  get empleadaRol(): Prisma.EmpleadaRolDelegate<ExtArgs>;

  /**
   * `prisma.movimiento`: Exposes CRUD operations for the **Movimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movimientos
    * const movimientos = await prisma.movimiento.findMany()
    * ```
    */
  get movimiento(): Prisma.MovimientoDelegate<ExtArgs>;

  /**
   * `prisma.catMov`: Exposes CRUD operations for the **CatMov** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatMovs
    * const catMovs = await prisma.catMov.findMany()
    * ```
    */
  get catMov(): Prisma.CatMovDelegate<ExtArgs>;

  /**
   * `prisma.subcatMovimiento`: Exposes CRUD operations for the **SubcatMovimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubcatMovimientos
    * const subcatMovimientos = await prisma.subcatMovimiento.findMany()
    * ```
    */
  get subcatMovimiento(): Prisma.SubcatMovimientoDelegate<ExtArgs>;

  /**
   * `prisma.detMov`: Exposes CRUD operations for the **DetMov** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetMovs
    * const detMovs = await prisma.detMov.findMany()
    * ```
    */
  get detMov(): Prisma.DetMovDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.20.0
   * Query Engine version: 06fc58a368dc7be9fbbbe894adf8d445d208c284
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Persona: 'Persona',
    Cliente: 'Cliente',
    Ciudad: 'Ciudad',
    Evento: 'Evento',
    TipoEvento: 'TipoEvento',
    Empleada: 'Empleada',
    EmpleadaRol: 'EmpleadaRol',
    Movimiento: 'Movimiento',
    CatMov: 'CatMov',
    SubcatMovimiento: 'SubcatMovimiento',
    DetMov: 'DetMov'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "persona" | "cliente" | "ciudad" | "evento" | "tipoEvento" | "empleada" | "empleadaRol" | "movimiento" | "catMov" | "subcatMovimiento" | "detMov"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Persona: {
        payload: Prisma.$PersonaPayload<ExtArgs>
        fields: Prisma.PersonaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          findFirst: {
            args: Prisma.PersonaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          findMany: {
            args: Prisma.PersonaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>[]
          }
          create: {
            args: Prisma.PersonaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          createMany: {
            args: Prisma.PersonaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>[]
          }
          delete: {
            args: Prisma.PersonaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          update: {
            args: Prisma.PersonaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          deleteMany: {
            args: Prisma.PersonaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          aggregate: {
            args: Prisma.PersonaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersona>
          }
          groupBy: {
            args: Prisma.PersonaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonaCountArgs<ExtArgs>
            result: $Utils.Optional<PersonaCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      Ciudad: {
        payload: Prisma.$CiudadPayload<ExtArgs>
        fields: Prisma.CiudadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CiudadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CiudadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>
          }
          findFirst: {
            args: Prisma.CiudadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CiudadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>
          }
          findMany: {
            args: Prisma.CiudadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>[]
          }
          create: {
            args: Prisma.CiudadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>
          }
          createMany: {
            args: Prisma.CiudadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CiudadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>[]
          }
          delete: {
            args: Prisma.CiudadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>
          }
          update: {
            args: Prisma.CiudadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>
          }
          deleteMany: {
            args: Prisma.CiudadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CiudadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CiudadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CiudadPayload>
          }
          aggregate: {
            args: Prisma.CiudadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCiudad>
          }
          groupBy: {
            args: Prisma.CiudadGroupByArgs<ExtArgs>
            result: $Utils.Optional<CiudadGroupByOutputType>[]
          }
          count: {
            args: Prisma.CiudadCountArgs<ExtArgs>
            result: $Utils.Optional<CiudadCountAggregateOutputType> | number
          }
        }
      }
      Evento: {
        payload: Prisma.$EventoPayload<ExtArgs>
        fields: Prisma.EventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findFirst: {
            args: Prisma.EventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findMany: {
            args: Prisma.EventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          create: {
            args: Prisma.EventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          createMany: {
            args: Prisma.EventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          delete: {
            args: Prisma.EventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          update: {
            args: Prisma.EventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          deleteMany: {
            args: Prisma.EventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          aggregate: {
            args: Prisma.EventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvento>
          }
          groupBy: {
            args: Prisma.EventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventoCountArgs<ExtArgs>
            result: $Utils.Optional<EventoCountAggregateOutputType> | number
          }
        }
      }
      TipoEvento: {
        payload: Prisma.$TipoEventoPayload<ExtArgs>
        fields: Prisma.TipoEventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoEventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoEventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>
          }
          findFirst: {
            args: Prisma.TipoEventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoEventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>
          }
          findMany: {
            args: Prisma.TipoEventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>[]
          }
          create: {
            args: Prisma.TipoEventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>
          }
          createMany: {
            args: Prisma.TipoEventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoEventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>[]
          }
          delete: {
            args: Prisma.TipoEventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>
          }
          update: {
            args: Prisma.TipoEventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>
          }
          deleteMany: {
            args: Prisma.TipoEventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoEventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TipoEventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEventoPayload>
          }
          aggregate: {
            args: Prisma.TipoEventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoEvento>
          }
          groupBy: {
            args: Prisma.TipoEventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoEventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoEventoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoEventoCountAggregateOutputType> | number
          }
        }
      }
      Empleada: {
        payload: Prisma.$EmpleadaPayload<ExtArgs>
        fields: Prisma.EmpleadaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpleadaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpleadaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>
          }
          findFirst: {
            args: Prisma.EmpleadaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpleadaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>
          }
          findMany: {
            args: Prisma.EmpleadaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>[]
          }
          create: {
            args: Prisma.EmpleadaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>
          }
          createMany: {
            args: Prisma.EmpleadaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpleadaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>[]
          }
          delete: {
            args: Prisma.EmpleadaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>
          }
          update: {
            args: Prisma.EmpleadaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>
          }
          deleteMany: {
            args: Prisma.EmpleadaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpleadaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpleadaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaPayload>
          }
          aggregate: {
            args: Prisma.EmpleadaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpleada>
          }
          groupBy: {
            args: Prisma.EmpleadaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpleadaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpleadaCountArgs<ExtArgs>
            result: $Utils.Optional<EmpleadaCountAggregateOutputType> | number
          }
        }
      }
      EmpleadaRol: {
        payload: Prisma.$EmpleadaRolPayload<ExtArgs>
        fields: Prisma.EmpleadaRolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpleadaRolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpleadaRolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>
          }
          findFirst: {
            args: Prisma.EmpleadaRolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpleadaRolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>
          }
          findMany: {
            args: Prisma.EmpleadaRolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>[]
          }
          create: {
            args: Prisma.EmpleadaRolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>
          }
          createMany: {
            args: Prisma.EmpleadaRolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmpleadaRolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>[]
          }
          delete: {
            args: Prisma.EmpleadaRolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>
          }
          update: {
            args: Prisma.EmpleadaRolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>
          }
          deleteMany: {
            args: Prisma.EmpleadaRolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmpleadaRolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmpleadaRolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmpleadaRolPayload>
          }
          aggregate: {
            args: Prisma.EmpleadaRolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmpleadaRol>
          }
          groupBy: {
            args: Prisma.EmpleadaRolGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmpleadaRolGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpleadaRolCountArgs<ExtArgs>
            result: $Utils.Optional<EmpleadaRolCountAggregateOutputType> | number
          }
        }
      }
      Movimiento: {
        payload: Prisma.$MovimientoPayload<ExtArgs>
        fields: Prisma.MovimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MovimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MovimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>
          }
          findFirst: {
            args: Prisma.MovimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MovimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>
          }
          findMany: {
            args: Prisma.MovimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>[]
          }
          create: {
            args: Prisma.MovimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>
          }
          createMany: {
            args: Prisma.MovimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MovimientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>[]
          }
          delete: {
            args: Prisma.MovimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>
          }
          update: {
            args: Prisma.MovimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>
          }
          deleteMany: {
            args: Prisma.MovimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MovimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MovimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovimientoPayload>
          }
          aggregate: {
            args: Prisma.MovimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMovimiento>
          }
          groupBy: {
            args: Prisma.MovimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MovimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MovimientoCountArgs<ExtArgs>
            result: $Utils.Optional<MovimientoCountAggregateOutputType> | number
          }
        }
      }
      CatMov: {
        payload: Prisma.$CatMovPayload<ExtArgs>
        fields: Prisma.CatMovFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatMovFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatMovFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>
          }
          findFirst: {
            args: Prisma.CatMovFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatMovFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>
          }
          findMany: {
            args: Prisma.CatMovFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>[]
          }
          create: {
            args: Prisma.CatMovCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>
          }
          createMany: {
            args: Prisma.CatMovCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatMovCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>[]
          }
          delete: {
            args: Prisma.CatMovDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>
          }
          update: {
            args: Prisma.CatMovUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>
          }
          deleteMany: {
            args: Prisma.CatMovDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatMovUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatMovUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatMovPayload>
          }
          aggregate: {
            args: Prisma.CatMovAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatMov>
          }
          groupBy: {
            args: Prisma.CatMovGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatMovGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatMovCountArgs<ExtArgs>
            result: $Utils.Optional<CatMovCountAggregateOutputType> | number
          }
        }
      }
      SubcatMovimiento: {
        payload: Prisma.$SubcatMovimientoPayload<ExtArgs>
        fields: Prisma.SubcatMovimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubcatMovimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubcatMovimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>
          }
          findFirst: {
            args: Prisma.SubcatMovimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubcatMovimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>
          }
          findMany: {
            args: Prisma.SubcatMovimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>[]
          }
          create: {
            args: Prisma.SubcatMovimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>
          }
          createMany: {
            args: Prisma.SubcatMovimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubcatMovimientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>[]
          }
          delete: {
            args: Prisma.SubcatMovimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>
          }
          update: {
            args: Prisma.SubcatMovimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>
          }
          deleteMany: {
            args: Prisma.SubcatMovimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubcatMovimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubcatMovimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcatMovimientoPayload>
          }
          aggregate: {
            args: Prisma.SubcatMovimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubcatMovimiento>
          }
          groupBy: {
            args: Prisma.SubcatMovimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubcatMovimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubcatMovimientoCountArgs<ExtArgs>
            result: $Utils.Optional<SubcatMovimientoCountAggregateOutputType> | number
          }
        }
      }
      DetMov: {
        payload: Prisma.$DetMovPayload<ExtArgs>
        fields: Prisma.DetMovFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetMovFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetMovFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>
          }
          findFirst: {
            args: Prisma.DetMovFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetMovFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>
          }
          findMany: {
            args: Prisma.DetMovFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>[]
          }
          create: {
            args: Prisma.DetMovCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>
          }
          createMany: {
            args: Prisma.DetMovCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetMovCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>[]
          }
          delete: {
            args: Prisma.DetMovDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>
          }
          update: {
            args: Prisma.DetMovUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>
          }
          deleteMany: {
            args: Prisma.DetMovDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetMovUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DetMovUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetMovPayload>
          }
          aggregate: {
            args: Prisma.DetMovAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetMov>
          }
          groupBy: {
            args: Prisma.DetMovGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetMovGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetMovCountArgs<ExtArgs>
            result: $Utils.Optional<DetMovCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    personas: number
    eventos: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personas?: boolean | ClienteCountOutputTypeCountPersonasArgs
    eventos?: boolean | ClienteCountOutputTypeCountEventosArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountPersonasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountEventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
  }


  /**
   * Count Type CiudadCountOutputType
   */

  export type CiudadCountOutputType = {
    clientes: number
  }

  export type CiudadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientes?: boolean | CiudadCountOutputTypeCountClientesArgs
  }

  // Custom InputTypes
  /**
   * CiudadCountOutputType without action
   */
  export type CiudadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CiudadCountOutputType
     */
    select?: CiudadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CiudadCountOutputType without action
   */
  export type CiudadCountOutputTypeCountClientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
  }


  /**
   * Count Type TipoEventoCountOutputType
   */

  export type TipoEventoCountOutputType = {
    eventos: number
  }

  export type TipoEventoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventos?: boolean | TipoEventoCountOutputTypeCountEventosArgs
  }

  // Custom InputTypes
  /**
   * TipoEventoCountOutputType without action
   */
  export type TipoEventoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEventoCountOutputType
     */
    select?: TipoEventoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoEventoCountOutputType without action
   */
  export type TipoEventoCountOutputTypeCountEventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
  }


  /**
   * Count Type EmpleadaCountOutputType
   */

  export type EmpleadaCountOutputType = {
    roles: number
    eventos: number
  }

  export type EmpleadaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | EmpleadaCountOutputTypeCountRolesArgs
    eventos?: boolean | EmpleadaCountOutputTypeCountEventosArgs
  }

  // Custom InputTypes
  /**
   * EmpleadaCountOutputType without action
   */
  export type EmpleadaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaCountOutputType
     */
    select?: EmpleadaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmpleadaCountOutputType without action
   */
  export type EmpleadaCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpleadaRolWhereInput
  }

  /**
   * EmpleadaCountOutputType without action
   */
  export type EmpleadaCountOutputTypeCountEventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
  }


  /**
   * Count Type CatMovCountOutputType
   */

  export type CatMovCountOutputType = {
    movimientos: number
    subcategorias: number
  }

  export type CatMovCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movimientos?: boolean | CatMovCountOutputTypeCountMovimientosArgs
    subcategorias?: boolean | CatMovCountOutputTypeCountSubcategoriasArgs
  }

  // Custom InputTypes
  /**
   * CatMovCountOutputType without action
   */
  export type CatMovCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMovCountOutputType
     */
    select?: CatMovCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatMovCountOutputType without action
   */
  export type CatMovCountOutputTypeCountMovimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovimientoWhereInput
  }

  /**
   * CatMovCountOutputType without action
   */
  export type CatMovCountOutputTypeCountSubcategoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcatMovimientoWhereInput
  }


  /**
   * Count Type SubcatMovimientoCountOutputType
   */

  export type SubcatMovimientoCountOutputType = {
    movimientos: number
    detalles: number
  }

  export type SubcatMovimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movimientos?: boolean | SubcatMovimientoCountOutputTypeCountMovimientosArgs
    detalles?: boolean | SubcatMovimientoCountOutputTypeCountDetallesArgs
  }

  // Custom InputTypes
  /**
   * SubcatMovimientoCountOutputType without action
   */
  export type SubcatMovimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimientoCountOutputType
     */
    select?: SubcatMovimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubcatMovimientoCountOutputType without action
   */
  export type SubcatMovimientoCountOutputTypeCountMovimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovimientoWhereInput
  }

  /**
   * SubcatMovimientoCountOutputType without action
   */
  export type SubcatMovimientoCountOutputTypeCountDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetMovWhereInput
  }


  /**
   * Count Type DetMovCountOutputType
   */

  export type DetMovCountOutputType = {
    movimientos: number
  }

  export type DetMovCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movimientos?: boolean | DetMovCountOutputTypeCountMovimientosArgs
  }

  // Custom InputTypes
  /**
   * DetMovCountOutputType without action
   */
  export type DetMovCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMovCountOutputType
     */
    select?: DetMovCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DetMovCountOutputType without action
   */
  export type DetMovCountOutputTypeCountMovimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovimientoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model Persona
   */

  export type AggregatePersona = {
    _count: PersonaCountAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  export type PersonaMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    telefono: string | null
    email: string | null
    cumpleanos: Date | null
    eventoCalendarioId: string | null
    clienteId: string | null
  }

  export type PersonaMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    telefono: string | null
    email: string | null
    cumpleanos: Date | null
    eventoCalendarioId: string | null
    clienteId: string | null
  }

  export type PersonaCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    telefono: number
    email: number
    cumpleanos: number
    eventoCalendarioId: number
    clienteId: number
    _all: number
  }


  export type PersonaMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    telefono?: true
    email?: true
    cumpleanos?: true
    eventoCalendarioId?: true
    clienteId?: true
  }

  export type PersonaMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    telefono?: true
    email?: true
    cumpleanos?: true
    eventoCalendarioId?: true
    clienteId?: true
  }

  export type PersonaCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    telefono?: true
    email?: true
    cumpleanos?: true
    eventoCalendarioId?: true
    clienteId?: true
    _all?: true
  }

  export type PersonaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Persona to aggregate.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personas
    **/
    _count?: true | PersonaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonaMaxAggregateInputType
  }

  export type GetPersonaAggregateType<T extends PersonaAggregateArgs> = {
        [P in keyof T & keyof AggregatePersona]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersona[P]>
      : GetScalarType<T[P], AggregatePersona[P]>
  }




  export type PersonaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaWhereInput
    orderBy?: PersonaOrderByWithAggregationInput | PersonaOrderByWithAggregationInput[]
    by: PersonaScalarFieldEnum[] | PersonaScalarFieldEnum
    having?: PersonaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonaCountAggregateInputType | true
    _min?: PersonaMinAggregateInputType
    _max?: PersonaMaxAggregateInputType
  }

  export type PersonaGroupByOutputType = {
    id: string
    nombre: string
    apellido: string
    telefono: string | null
    email: string | null
    cumpleanos: Date | null
    eventoCalendarioId: string | null
    clienteId: string | null
    _count: PersonaCountAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  type GetPersonaGroupByPayload<T extends PersonaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonaGroupByOutputType[P]>
            : GetScalarType<T[P], PersonaGroupByOutputType[P]>
        }
      >
    >


  export type PersonaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    telefono?: boolean
    email?: boolean
    cumpleanos?: boolean
    eventoCalendarioId?: boolean
    clienteId?: boolean
    cliente?: boolean | Persona$clienteArgs<ExtArgs>
  }, ExtArgs["result"]["persona"]>

  export type PersonaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    telefono?: boolean
    email?: boolean
    cumpleanos?: boolean
    eventoCalendarioId?: boolean
    clienteId?: boolean
    cliente?: boolean | Persona$clienteArgs<ExtArgs>
  }, ExtArgs["result"]["persona"]>

  export type PersonaSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    telefono?: boolean
    email?: boolean
    cumpleanos?: boolean
    eventoCalendarioId?: boolean
    clienteId?: boolean
  }

  export type PersonaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | Persona$clienteArgs<ExtArgs>
  }
  export type PersonaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | Persona$clienteArgs<ExtArgs>
  }

  export type $PersonaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Persona"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      apellido: string
      telefono: string | null
      email: string | null
      cumpleanos: Date | null
      eventoCalendarioId: string | null
      clienteId: string | null
    }, ExtArgs["result"]["persona"]>
    composites: {}
  }

  type PersonaGetPayload<S extends boolean | null | undefined | PersonaDefaultArgs> = $Result.GetResult<Prisma.$PersonaPayload, S>

  type PersonaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonaCountAggregateInputType | true
    }

  export interface PersonaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Persona'], meta: { name: 'Persona' } }
    /**
     * Find zero or one Persona that matches the filter.
     * @param {PersonaFindUniqueArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonaFindUniqueArgs>(args: SelectSubset<T, PersonaFindUniqueArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Persona that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonaFindUniqueOrThrowArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonaFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Persona that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaFindFirstArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonaFindFirstArgs>(args?: SelectSubset<T, PersonaFindFirstArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Persona that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaFindFirstOrThrowArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonaFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Personas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personas
     * const personas = await prisma.persona.findMany()
     * 
     * // Get first 10 Personas
     * const personas = await prisma.persona.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personaWithIdOnly = await prisma.persona.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonaFindManyArgs>(args?: SelectSubset<T, PersonaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Persona.
     * @param {PersonaCreateArgs} args - Arguments to create a Persona.
     * @example
     * // Create one Persona
     * const Persona = await prisma.persona.create({
     *   data: {
     *     // ... data to create a Persona
     *   }
     * })
     * 
     */
    create<T extends PersonaCreateArgs>(args: SelectSubset<T, PersonaCreateArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Personas.
     * @param {PersonaCreateManyArgs} args - Arguments to create many Personas.
     * @example
     * // Create many Personas
     * const persona = await prisma.persona.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonaCreateManyArgs>(args?: SelectSubset<T, PersonaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personas and returns the data saved in the database.
     * @param {PersonaCreateManyAndReturnArgs} args - Arguments to create many Personas.
     * @example
     * // Create many Personas
     * const persona = await prisma.persona.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personas and only return the `id`
     * const personaWithIdOnly = await prisma.persona.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonaCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Persona.
     * @param {PersonaDeleteArgs} args - Arguments to delete one Persona.
     * @example
     * // Delete one Persona
     * const Persona = await prisma.persona.delete({
     *   where: {
     *     // ... filter to delete one Persona
     *   }
     * })
     * 
     */
    delete<T extends PersonaDeleteArgs>(args: SelectSubset<T, PersonaDeleteArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Persona.
     * @param {PersonaUpdateArgs} args - Arguments to update one Persona.
     * @example
     * // Update one Persona
     * const persona = await prisma.persona.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonaUpdateArgs>(args: SelectSubset<T, PersonaUpdateArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Personas.
     * @param {PersonaDeleteManyArgs} args - Arguments to filter Personas to delete.
     * @example
     * // Delete a few Personas
     * const { count } = await prisma.persona.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonaDeleteManyArgs>(args?: SelectSubset<T, PersonaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personas
     * const persona = await prisma.persona.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonaUpdateManyArgs>(args: SelectSubset<T, PersonaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Persona.
     * @param {PersonaUpsertArgs} args - Arguments to update or create a Persona.
     * @example
     * // Update or create a Persona
     * const persona = await prisma.persona.upsert({
     *   create: {
     *     // ... data to create a Persona
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Persona we want to update
     *   }
     * })
     */
    upsert<T extends PersonaUpsertArgs>(args: SelectSubset<T, PersonaUpsertArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaCountArgs} args - Arguments to filter Personas to count.
     * @example
     * // Count the number of Personas
     * const count = await prisma.persona.count({
     *   where: {
     *     // ... the filter for the Personas we want to count
     *   }
     * })
    **/
    count<T extends PersonaCountArgs>(
      args?: Subset<T, PersonaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonaAggregateArgs>(args: Subset<T, PersonaAggregateArgs>): Prisma.PrismaPromise<GetPersonaAggregateType<T>>

    /**
     * Group by Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonaGroupByArgs['orderBy'] }
        : { orderBy?: PersonaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Persona model
   */
  readonly fields: PersonaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Persona.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends Persona$clienteArgs<ExtArgs> = {}>(args?: Subset<T, Persona$clienteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Persona model
   */ 
  interface PersonaFieldRefs {
    readonly id: FieldRef<"Persona", 'String'>
    readonly nombre: FieldRef<"Persona", 'String'>
    readonly apellido: FieldRef<"Persona", 'String'>
    readonly telefono: FieldRef<"Persona", 'String'>
    readonly email: FieldRef<"Persona", 'String'>
    readonly cumpleanos: FieldRef<"Persona", 'DateTime'>
    readonly eventoCalendarioId: FieldRef<"Persona", 'String'>
    readonly clienteId: FieldRef<"Persona", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Persona findUnique
   */
  export type PersonaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona findUniqueOrThrow
   */
  export type PersonaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona findFirst
   */
  export type PersonaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personas.
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personas.
     */
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Persona findFirstOrThrow
   */
  export type PersonaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personas.
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personas.
     */
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Persona findMany
   */
  export type PersonaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Personas to fetch.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personas.
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Persona create
   */
  export type PersonaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * The data needed to create a Persona.
     */
    data: XOR<PersonaCreateInput, PersonaUncheckedCreateInput>
  }

  /**
   * Persona createMany
   */
  export type PersonaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Personas.
     */
    data: PersonaCreateManyInput | PersonaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Persona createManyAndReturn
   */
  export type PersonaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Personas.
     */
    data: PersonaCreateManyInput | PersonaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Persona update
   */
  export type PersonaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * The data needed to update a Persona.
     */
    data: XOR<PersonaUpdateInput, PersonaUncheckedUpdateInput>
    /**
     * Choose, which Persona to update.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona updateMany
   */
  export type PersonaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Personas.
     */
    data: XOR<PersonaUpdateManyMutationInput, PersonaUncheckedUpdateManyInput>
    /**
     * Filter which Personas to update
     */
    where?: PersonaWhereInput
  }

  /**
   * Persona upsert
   */
  export type PersonaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * The filter to search for the Persona to update in case it exists.
     */
    where: PersonaWhereUniqueInput
    /**
     * In case the Persona found by the `where` argument doesn't exist, create a new Persona with this data.
     */
    create: XOR<PersonaCreateInput, PersonaUncheckedCreateInput>
    /**
     * In case the Persona was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonaUpdateInput, PersonaUncheckedUpdateInput>
  }

  /**
   * Persona delete
   */
  export type PersonaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter which Persona to delete.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona deleteMany
   */
  export type PersonaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personas to delete
     */
    where?: PersonaWhereInput
  }

  /**
   * Persona.cliente
   */
  export type Persona$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
  }

  /**
   * Persona without action
   */
  export type PersonaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    email: string | null
    ciudadId: string | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    email: string | null
    ciudadId: string | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    nombre: number
    email: number
    ciudadId: number
    _all: number
  }


  export type ClienteMinAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    ciudadId?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    ciudadId?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    nombre?: true
    email?: true
    ciudadId?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: string
    nombre: string
    email: string
    ciudadId: string
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    email?: boolean
    ciudadId?: boolean
    ciudad?: boolean | CiudadDefaultArgs<ExtArgs>
    personas?: boolean | Cliente$personasArgs<ExtArgs>
    eventos?: boolean | Cliente$eventosArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    email?: boolean
    ciudadId?: boolean
    ciudad?: boolean | CiudadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    nombre?: boolean
    email?: boolean
    ciudadId?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ciudad?: boolean | CiudadDefaultArgs<ExtArgs>
    personas?: boolean | Cliente$personasArgs<ExtArgs>
    eventos?: boolean | Cliente$eventosArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ciudad?: boolean | CiudadDefaultArgs<ExtArgs>
  }

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      ciudad: Prisma.$CiudadPayload<ExtArgs>
      personas: Prisma.$PersonaPayload<ExtArgs>[]
      eventos: Prisma.$EventoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      email: string
      ciudadId: string
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ciudad<T extends CiudadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CiudadDefaultArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    personas<T extends Cliente$personasArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$personasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findMany"> | Null>
    eventos<T extends Cliente$eventosArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$eventosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'String'>
    readonly nombre: FieldRef<"Cliente", 'String'>
    readonly email: FieldRef<"Cliente", 'String'>
    readonly ciudadId: FieldRef<"Cliente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente.personas
   */
  export type Cliente$personasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    where?: PersonaWhereInput
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    cursor?: PersonaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Cliente.eventos
   */
  export type Cliente$eventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    cursor?: EventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model Ciudad
   */

  export type AggregateCiudad = {
    _count: CiudadCountAggregateOutputType | null
    _min: CiudadMinAggregateOutputType | null
    _max: CiudadMaxAggregateOutputType | null
  }

  export type CiudadMinAggregateOutputType = {
    id: string | null
    nombre: string | null
  }

  export type CiudadMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
  }

  export type CiudadCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type CiudadMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CiudadMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type CiudadCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type CiudadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ciudad to aggregate.
     */
    where?: CiudadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ciudads to fetch.
     */
    orderBy?: CiudadOrderByWithRelationInput | CiudadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CiudadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ciudads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ciudads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ciudads
    **/
    _count?: true | CiudadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CiudadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CiudadMaxAggregateInputType
  }

  export type GetCiudadAggregateType<T extends CiudadAggregateArgs> = {
        [P in keyof T & keyof AggregateCiudad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCiudad[P]>
      : GetScalarType<T[P], AggregateCiudad[P]>
  }




  export type CiudadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CiudadWhereInput
    orderBy?: CiudadOrderByWithAggregationInput | CiudadOrderByWithAggregationInput[]
    by: CiudadScalarFieldEnum[] | CiudadScalarFieldEnum
    having?: CiudadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CiudadCountAggregateInputType | true
    _min?: CiudadMinAggregateInputType
    _max?: CiudadMaxAggregateInputType
  }

  export type CiudadGroupByOutputType = {
    id: string
    nombre: string
    _count: CiudadCountAggregateOutputType | null
    _min: CiudadMinAggregateOutputType | null
    _max: CiudadMaxAggregateOutputType | null
  }

  type GetCiudadGroupByPayload<T extends CiudadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CiudadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CiudadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CiudadGroupByOutputType[P]>
            : GetScalarType<T[P], CiudadGroupByOutputType[P]>
        }
      >
    >


  export type CiudadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    clientes?: boolean | Ciudad$clientesArgs<ExtArgs>
    _count?: boolean | CiudadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ciudad"]>

  export type CiudadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["ciudad"]>

  export type CiudadSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type CiudadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientes?: boolean | Ciudad$clientesArgs<ExtArgs>
    _count?: boolean | CiudadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CiudadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CiudadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ciudad"
    objects: {
      clientes: Prisma.$ClientePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
    }, ExtArgs["result"]["ciudad"]>
    composites: {}
  }

  type CiudadGetPayload<S extends boolean | null | undefined | CiudadDefaultArgs> = $Result.GetResult<Prisma.$CiudadPayload, S>

  type CiudadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CiudadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CiudadCountAggregateInputType | true
    }

  export interface CiudadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ciudad'], meta: { name: 'Ciudad' } }
    /**
     * Find zero or one Ciudad that matches the filter.
     * @param {CiudadFindUniqueArgs} args - Arguments to find a Ciudad
     * @example
     * // Get one Ciudad
     * const ciudad = await prisma.ciudad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CiudadFindUniqueArgs>(args: SelectSubset<T, CiudadFindUniqueArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Ciudad that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CiudadFindUniqueOrThrowArgs} args - Arguments to find a Ciudad
     * @example
     * // Get one Ciudad
     * const ciudad = await prisma.ciudad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CiudadFindUniqueOrThrowArgs>(args: SelectSubset<T, CiudadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Ciudad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadFindFirstArgs} args - Arguments to find a Ciudad
     * @example
     * // Get one Ciudad
     * const ciudad = await prisma.ciudad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CiudadFindFirstArgs>(args?: SelectSubset<T, CiudadFindFirstArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Ciudad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadFindFirstOrThrowArgs} args - Arguments to find a Ciudad
     * @example
     * // Get one Ciudad
     * const ciudad = await prisma.ciudad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CiudadFindFirstOrThrowArgs>(args?: SelectSubset<T, CiudadFindFirstOrThrowArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Ciudads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ciudads
     * const ciudads = await prisma.ciudad.findMany()
     * 
     * // Get first 10 Ciudads
     * const ciudads = await prisma.ciudad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ciudadWithIdOnly = await prisma.ciudad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CiudadFindManyArgs>(args?: SelectSubset<T, CiudadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Ciudad.
     * @param {CiudadCreateArgs} args - Arguments to create a Ciudad.
     * @example
     * // Create one Ciudad
     * const Ciudad = await prisma.ciudad.create({
     *   data: {
     *     // ... data to create a Ciudad
     *   }
     * })
     * 
     */
    create<T extends CiudadCreateArgs>(args: SelectSubset<T, CiudadCreateArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Ciudads.
     * @param {CiudadCreateManyArgs} args - Arguments to create many Ciudads.
     * @example
     * // Create many Ciudads
     * const ciudad = await prisma.ciudad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CiudadCreateManyArgs>(args?: SelectSubset<T, CiudadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ciudads and returns the data saved in the database.
     * @param {CiudadCreateManyAndReturnArgs} args - Arguments to create many Ciudads.
     * @example
     * // Create many Ciudads
     * const ciudad = await prisma.ciudad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ciudads and only return the `id`
     * const ciudadWithIdOnly = await prisma.ciudad.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CiudadCreateManyAndReturnArgs>(args?: SelectSubset<T, CiudadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Ciudad.
     * @param {CiudadDeleteArgs} args - Arguments to delete one Ciudad.
     * @example
     * // Delete one Ciudad
     * const Ciudad = await prisma.ciudad.delete({
     *   where: {
     *     // ... filter to delete one Ciudad
     *   }
     * })
     * 
     */
    delete<T extends CiudadDeleteArgs>(args: SelectSubset<T, CiudadDeleteArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Ciudad.
     * @param {CiudadUpdateArgs} args - Arguments to update one Ciudad.
     * @example
     * // Update one Ciudad
     * const ciudad = await prisma.ciudad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CiudadUpdateArgs>(args: SelectSubset<T, CiudadUpdateArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Ciudads.
     * @param {CiudadDeleteManyArgs} args - Arguments to filter Ciudads to delete.
     * @example
     * // Delete a few Ciudads
     * const { count } = await prisma.ciudad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CiudadDeleteManyArgs>(args?: SelectSubset<T, CiudadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ciudads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ciudads
     * const ciudad = await prisma.ciudad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CiudadUpdateManyArgs>(args: SelectSubset<T, CiudadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ciudad.
     * @param {CiudadUpsertArgs} args - Arguments to update or create a Ciudad.
     * @example
     * // Update or create a Ciudad
     * const ciudad = await prisma.ciudad.upsert({
     *   create: {
     *     // ... data to create a Ciudad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ciudad we want to update
     *   }
     * })
     */
    upsert<T extends CiudadUpsertArgs>(args: SelectSubset<T, CiudadUpsertArgs<ExtArgs>>): Prisma__CiudadClient<$Result.GetResult<Prisma.$CiudadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Ciudads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadCountArgs} args - Arguments to filter Ciudads to count.
     * @example
     * // Count the number of Ciudads
     * const count = await prisma.ciudad.count({
     *   where: {
     *     // ... the filter for the Ciudads we want to count
     *   }
     * })
    **/
    count<T extends CiudadCountArgs>(
      args?: Subset<T, CiudadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CiudadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ciudad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CiudadAggregateArgs>(args: Subset<T, CiudadAggregateArgs>): Prisma.PrismaPromise<GetCiudadAggregateType<T>>

    /**
     * Group by Ciudad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiudadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CiudadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CiudadGroupByArgs['orderBy'] }
        : { orderBy?: CiudadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CiudadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCiudadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ciudad model
   */
  readonly fields: CiudadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ciudad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CiudadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientes<T extends Ciudad$clientesArgs<ExtArgs> = {}>(args?: Subset<T, Ciudad$clientesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ciudad model
   */ 
  interface CiudadFieldRefs {
    readonly id: FieldRef<"Ciudad", 'String'>
    readonly nombre: FieldRef<"Ciudad", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ciudad findUnique
   */
  export type CiudadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * Filter, which Ciudad to fetch.
     */
    where: CiudadWhereUniqueInput
  }

  /**
   * Ciudad findUniqueOrThrow
   */
  export type CiudadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * Filter, which Ciudad to fetch.
     */
    where: CiudadWhereUniqueInput
  }

  /**
   * Ciudad findFirst
   */
  export type CiudadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * Filter, which Ciudad to fetch.
     */
    where?: CiudadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ciudads to fetch.
     */
    orderBy?: CiudadOrderByWithRelationInput | CiudadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ciudads.
     */
    cursor?: CiudadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ciudads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ciudads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ciudads.
     */
    distinct?: CiudadScalarFieldEnum | CiudadScalarFieldEnum[]
  }

  /**
   * Ciudad findFirstOrThrow
   */
  export type CiudadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * Filter, which Ciudad to fetch.
     */
    where?: CiudadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ciudads to fetch.
     */
    orderBy?: CiudadOrderByWithRelationInput | CiudadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ciudads.
     */
    cursor?: CiudadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ciudads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ciudads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ciudads.
     */
    distinct?: CiudadScalarFieldEnum | CiudadScalarFieldEnum[]
  }

  /**
   * Ciudad findMany
   */
  export type CiudadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * Filter, which Ciudads to fetch.
     */
    where?: CiudadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ciudads to fetch.
     */
    orderBy?: CiudadOrderByWithRelationInput | CiudadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ciudads.
     */
    cursor?: CiudadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ciudads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ciudads.
     */
    skip?: number
    distinct?: CiudadScalarFieldEnum | CiudadScalarFieldEnum[]
  }

  /**
   * Ciudad create
   */
  export type CiudadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * The data needed to create a Ciudad.
     */
    data: XOR<CiudadCreateInput, CiudadUncheckedCreateInput>
  }

  /**
   * Ciudad createMany
   */
  export type CiudadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ciudads.
     */
    data: CiudadCreateManyInput | CiudadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ciudad createManyAndReturn
   */
  export type CiudadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Ciudads.
     */
    data: CiudadCreateManyInput | CiudadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ciudad update
   */
  export type CiudadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * The data needed to update a Ciudad.
     */
    data: XOR<CiudadUpdateInput, CiudadUncheckedUpdateInput>
    /**
     * Choose, which Ciudad to update.
     */
    where: CiudadWhereUniqueInput
  }

  /**
   * Ciudad updateMany
   */
  export type CiudadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ciudads.
     */
    data: XOR<CiudadUpdateManyMutationInput, CiudadUncheckedUpdateManyInput>
    /**
     * Filter which Ciudads to update
     */
    where?: CiudadWhereInput
  }

  /**
   * Ciudad upsert
   */
  export type CiudadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * The filter to search for the Ciudad to update in case it exists.
     */
    where: CiudadWhereUniqueInput
    /**
     * In case the Ciudad found by the `where` argument doesn't exist, create a new Ciudad with this data.
     */
    create: XOR<CiudadCreateInput, CiudadUncheckedCreateInput>
    /**
     * In case the Ciudad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CiudadUpdateInput, CiudadUncheckedUpdateInput>
  }

  /**
   * Ciudad delete
   */
  export type CiudadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
    /**
     * Filter which Ciudad to delete.
     */
    where: CiudadWhereUniqueInput
  }

  /**
   * Ciudad deleteMany
   */
  export type CiudadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ciudads to delete
     */
    where?: CiudadWhereInput
  }

  /**
   * Ciudad.clientes
   */
  export type Ciudad$clientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    cursor?: ClienteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Ciudad without action
   */
  export type CiudadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ciudad
     */
    select?: CiudadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CiudadInclude<ExtArgs> | null
  }


  /**
   * Model Evento
   */

  export type AggregateEvento = {
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  export type EventoAvgAggregateOutputType = {
    numInvitados: number | null
  }

  export type EventoSumAggregateOutputType = {
    numInvitados: number | null
  }

  export type EventoMinAggregateOutputType = {
    id: string | null
    fecha: Date | null
    numInvitados: number | null
    tipoEventoId: string | null
    clienteId: string | null
    carpetaId: string | null
    estado: string | null
    plannerId: string | null
  }

  export type EventoMaxAggregateOutputType = {
    id: string | null
    fecha: Date | null
    numInvitados: number | null
    tipoEventoId: string | null
    clienteId: string | null
    carpetaId: string | null
    estado: string | null
    plannerId: string | null
  }

  export type EventoCountAggregateOutputType = {
    id: number
    fecha: number
    numInvitados: number
    tipoEventoId: number
    clienteId: number
    carpetaId: number
    estado: number
    plannerId: number
    _all: number
  }


  export type EventoAvgAggregateInputType = {
    numInvitados?: true
  }

  export type EventoSumAggregateInputType = {
    numInvitados?: true
  }

  export type EventoMinAggregateInputType = {
    id?: true
    fecha?: true
    numInvitados?: true
    tipoEventoId?: true
    clienteId?: true
    carpetaId?: true
    estado?: true
    plannerId?: true
  }

  export type EventoMaxAggregateInputType = {
    id?: true
    fecha?: true
    numInvitados?: true
    tipoEventoId?: true
    clienteId?: true
    carpetaId?: true
    estado?: true
    plannerId?: true
  }

  export type EventoCountAggregateInputType = {
    id?: true
    fecha?: true
    numInvitados?: true
    tipoEventoId?: true
    clienteId?: true
    carpetaId?: true
    estado?: true
    plannerId?: true
    _all?: true
  }

  export type EventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evento to aggregate.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eventos
    **/
    _count?: true | EventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventoMaxAggregateInputType
  }

  export type GetEventoAggregateType<T extends EventoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvento[P]>
      : GetScalarType<T[P], AggregateEvento[P]>
  }




  export type EventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithAggregationInput | EventoOrderByWithAggregationInput[]
    by: EventoScalarFieldEnum[] | EventoScalarFieldEnum
    having?: EventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventoCountAggregateInputType | true
    _avg?: EventoAvgAggregateInputType
    _sum?: EventoSumAggregateInputType
    _min?: EventoMinAggregateInputType
    _max?: EventoMaxAggregateInputType
  }

  export type EventoGroupByOutputType = {
    id: string
    fecha: Date
    numInvitados: number
    tipoEventoId: string
    clienteId: string
    carpetaId: string | null
    estado: string
    plannerId: string
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  type GetEventoGroupByPayload<T extends EventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventoGroupByOutputType[P]>
            : GetScalarType<T[P], EventoGroupByOutputType[P]>
        }
      >
    >


  export type EventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    numInvitados?: boolean
    tipoEventoId?: boolean
    clienteId?: boolean
    carpetaId?: boolean
    estado?: boolean
    plannerId?: boolean
    tipoEvento?: boolean | TipoEventoDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    planner?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    numInvitados?: boolean
    tipoEventoId?: boolean
    clienteId?: boolean
    carpetaId?: boolean
    estado?: boolean
    plannerId?: boolean
    tipoEvento?: boolean | TipoEventoDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    planner?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectScalar = {
    id?: boolean
    fecha?: boolean
    numInvitados?: boolean
    tipoEventoId?: boolean
    clienteId?: boolean
    carpetaId?: boolean
    estado?: boolean
    plannerId?: boolean
  }

  export type EventoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoEvento?: boolean | TipoEventoDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    planner?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }
  export type EventoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoEvento?: boolean | TipoEventoDefaultArgs<ExtArgs>
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    planner?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }

  export type $EventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evento"
    objects: {
      tipoEvento: Prisma.$TipoEventoPayload<ExtArgs>
      cliente: Prisma.$ClientePayload<ExtArgs>
      planner: Prisma.$EmpleadaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fecha: Date
      numInvitados: number
      tipoEventoId: string
      clienteId: string
      carpetaId: string | null
      estado: string
      plannerId: string
    }, ExtArgs["result"]["evento"]>
    composites: {}
  }

  type EventoGetPayload<S extends boolean | null | undefined | EventoDefaultArgs> = $Result.GetResult<Prisma.$EventoPayload, S>

  type EventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventoCountAggregateInputType | true
    }

  export interface EventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evento'], meta: { name: 'Evento' } }
    /**
     * Find zero or one Evento that matches the filter.
     * @param {EventoFindUniqueArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventoFindUniqueArgs>(args: SelectSubset<T, EventoFindUniqueArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventoFindUniqueOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventoFindUniqueOrThrowArgs>(args: SelectSubset<T, EventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventoFindFirstArgs>(args?: SelectSubset<T, EventoFindFirstArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventoFindFirstOrThrowArgs>(args?: SelectSubset<T, EventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventos
     * const eventos = await prisma.evento.findMany()
     * 
     * // Get first 10 Eventos
     * const eventos = await prisma.evento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventoWithIdOnly = await prisma.evento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventoFindManyArgs>(args?: SelectSubset<T, EventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evento.
     * @param {EventoCreateArgs} args - Arguments to create a Evento.
     * @example
     * // Create one Evento
     * const Evento = await prisma.evento.create({
     *   data: {
     *     // ... data to create a Evento
     *   }
     * })
     * 
     */
    create<T extends EventoCreateArgs>(args: SelectSubset<T, EventoCreateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eventos.
     * @param {EventoCreateManyArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventoCreateManyArgs>(args?: SelectSubset<T, EventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Eventos and returns the data saved in the database.
     * @param {EventoCreateManyAndReturnArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Eventos and only return the `id`
     * const eventoWithIdOnly = await prisma.evento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventoCreateManyAndReturnArgs>(args?: SelectSubset<T, EventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evento.
     * @param {EventoDeleteArgs} args - Arguments to delete one Evento.
     * @example
     * // Delete one Evento
     * const Evento = await prisma.evento.delete({
     *   where: {
     *     // ... filter to delete one Evento
     *   }
     * })
     * 
     */
    delete<T extends EventoDeleteArgs>(args: SelectSubset<T, EventoDeleteArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evento.
     * @param {EventoUpdateArgs} args - Arguments to update one Evento.
     * @example
     * // Update one Evento
     * const evento = await prisma.evento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventoUpdateArgs>(args: SelectSubset<T, EventoUpdateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eventos.
     * @param {EventoDeleteManyArgs} args - Arguments to filter Eventos to delete.
     * @example
     * // Delete a few Eventos
     * const { count } = await prisma.evento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventoDeleteManyArgs>(args?: SelectSubset<T, EventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventos
     * const evento = await prisma.evento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventoUpdateManyArgs>(args: SelectSubset<T, EventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evento.
     * @param {EventoUpsertArgs} args - Arguments to update or create a Evento.
     * @example
     * // Update or create a Evento
     * const evento = await prisma.evento.upsert({
     *   create: {
     *     // ... data to create a Evento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evento we want to update
     *   }
     * })
     */
    upsert<T extends EventoUpsertArgs>(args: SelectSubset<T, EventoUpsertArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoCountArgs} args - Arguments to filter Eventos to count.
     * @example
     * // Count the number of Eventos
     * const count = await prisma.evento.count({
     *   where: {
     *     // ... the filter for the Eventos we want to count
     *   }
     * })
    **/
    count<T extends EventoCountArgs>(
      args?: Subset<T, EventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventoAggregateArgs>(args: Subset<T, EventoAggregateArgs>): Prisma.PrismaPromise<GetEventoAggregateType<T>>

    /**
     * Group by Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventoGroupByArgs['orderBy'] }
        : { orderBy?: EventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evento model
   */
  readonly fields: EventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipoEvento<T extends TipoEventoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoEventoDefaultArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    planner<T extends EmpleadaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpleadaDefaultArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evento model
   */ 
  interface EventoFieldRefs {
    readonly id: FieldRef<"Evento", 'String'>
    readonly fecha: FieldRef<"Evento", 'DateTime'>
    readonly numInvitados: FieldRef<"Evento", 'Int'>
    readonly tipoEventoId: FieldRef<"Evento", 'String'>
    readonly clienteId: FieldRef<"Evento", 'String'>
    readonly carpetaId: FieldRef<"Evento", 'String'>
    readonly estado: FieldRef<"Evento", 'String'>
    readonly plannerId: FieldRef<"Evento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Evento findUnique
   */
  export type EventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findUniqueOrThrow
   */
  export type EventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findFirst
   */
  export type EventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findFirstOrThrow
   */
  export type EventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findMany
   */
  export type EventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Eventos to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento create
   */
  export type EventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to create a Evento.
     */
    data: XOR<EventoCreateInput, EventoUncheckedCreateInput>
  }

  /**
   * Evento createMany
   */
  export type EventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evento createManyAndReturn
   */
  export type EventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evento update
   */
  export type EventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to update a Evento.
     */
    data: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
    /**
     * Choose, which Evento to update.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento updateMany
   */
  export type EventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eventos.
     */
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyInput>
    /**
     * Filter which Eventos to update
     */
    where?: EventoWhereInput
  }

  /**
   * Evento upsert
   */
  export type EventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The filter to search for the Evento to update in case it exists.
     */
    where: EventoWhereUniqueInput
    /**
     * In case the Evento found by the `where` argument doesn't exist, create a new Evento with this data.
     */
    create: XOR<EventoCreateInput, EventoUncheckedCreateInput>
    /**
     * In case the Evento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
  }

  /**
   * Evento delete
   */
  export type EventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter which Evento to delete.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento deleteMany
   */
  export type EventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eventos to delete
     */
    where?: EventoWhereInput
  }

  /**
   * Evento without action
   */
  export type EventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
  }


  /**
   * Model TipoEvento
   */

  export type AggregateTipoEvento = {
    _count: TipoEventoCountAggregateOutputType | null
    _min: TipoEventoMinAggregateOutputType | null
    _max: TipoEventoMaxAggregateOutputType | null
  }

  export type TipoEventoMinAggregateOutputType = {
    id: string | null
    nombre: string | null
  }

  export type TipoEventoMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
  }

  export type TipoEventoCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type TipoEventoMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type TipoEventoMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type TipoEventoCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type TipoEventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEvento to aggregate.
     */
    where?: TipoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEventos to fetch.
     */
    orderBy?: TipoEventoOrderByWithRelationInput | TipoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoEventos
    **/
    _count?: true | TipoEventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoEventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoEventoMaxAggregateInputType
  }

  export type GetTipoEventoAggregateType<T extends TipoEventoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoEvento[P]>
      : GetScalarType<T[P], AggregateTipoEvento[P]>
  }




  export type TipoEventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoEventoWhereInput
    orderBy?: TipoEventoOrderByWithAggregationInput | TipoEventoOrderByWithAggregationInput[]
    by: TipoEventoScalarFieldEnum[] | TipoEventoScalarFieldEnum
    having?: TipoEventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoEventoCountAggregateInputType | true
    _min?: TipoEventoMinAggregateInputType
    _max?: TipoEventoMaxAggregateInputType
  }

  export type TipoEventoGroupByOutputType = {
    id: string
    nombre: string
    _count: TipoEventoCountAggregateOutputType | null
    _min: TipoEventoMinAggregateOutputType | null
    _max: TipoEventoMaxAggregateOutputType | null
  }

  type GetTipoEventoGroupByPayload<T extends TipoEventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoEventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoEventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoEventoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoEventoGroupByOutputType[P]>
        }
      >
    >


  export type TipoEventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    eventos?: boolean | TipoEvento$eventosArgs<ExtArgs>
    _count?: boolean | TipoEventoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoEvento"]>

  export type TipoEventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
  }, ExtArgs["result"]["tipoEvento"]>

  export type TipoEventoSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type TipoEventoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventos?: boolean | TipoEvento$eventosArgs<ExtArgs>
    _count?: boolean | TipoEventoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoEventoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoEventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoEvento"
    objects: {
      eventos: Prisma.$EventoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
    }, ExtArgs["result"]["tipoEvento"]>
    composites: {}
  }

  type TipoEventoGetPayload<S extends boolean | null | undefined | TipoEventoDefaultArgs> = $Result.GetResult<Prisma.$TipoEventoPayload, S>

  type TipoEventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TipoEventoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TipoEventoCountAggregateInputType | true
    }

  export interface TipoEventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoEvento'], meta: { name: 'TipoEvento' } }
    /**
     * Find zero or one TipoEvento that matches the filter.
     * @param {TipoEventoFindUniqueArgs} args - Arguments to find a TipoEvento
     * @example
     * // Get one TipoEvento
     * const tipoEvento = await prisma.tipoEvento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoEventoFindUniqueArgs>(args: SelectSubset<T, TipoEventoFindUniqueArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TipoEvento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TipoEventoFindUniqueOrThrowArgs} args - Arguments to find a TipoEvento
     * @example
     * // Get one TipoEvento
     * const tipoEvento = await prisma.tipoEvento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoEventoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoEventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TipoEvento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEventoFindFirstArgs} args - Arguments to find a TipoEvento
     * @example
     * // Get one TipoEvento
     * const tipoEvento = await prisma.tipoEvento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoEventoFindFirstArgs>(args?: SelectSubset<T, TipoEventoFindFirstArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TipoEvento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEventoFindFirstOrThrowArgs} args - Arguments to find a TipoEvento
     * @example
     * // Get one TipoEvento
     * const tipoEvento = await prisma.tipoEvento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoEventoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoEventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TipoEventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoEventos
     * const tipoEventos = await prisma.tipoEvento.findMany()
     * 
     * // Get first 10 TipoEventos
     * const tipoEventos = await prisma.tipoEvento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoEventoWithIdOnly = await prisma.tipoEvento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoEventoFindManyArgs>(args?: SelectSubset<T, TipoEventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TipoEvento.
     * @param {TipoEventoCreateArgs} args - Arguments to create a TipoEvento.
     * @example
     * // Create one TipoEvento
     * const TipoEvento = await prisma.tipoEvento.create({
     *   data: {
     *     // ... data to create a TipoEvento
     *   }
     * })
     * 
     */
    create<T extends TipoEventoCreateArgs>(args: SelectSubset<T, TipoEventoCreateArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TipoEventos.
     * @param {TipoEventoCreateManyArgs} args - Arguments to create many TipoEventos.
     * @example
     * // Create many TipoEventos
     * const tipoEvento = await prisma.tipoEvento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoEventoCreateManyArgs>(args?: SelectSubset<T, TipoEventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoEventos and returns the data saved in the database.
     * @param {TipoEventoCreateManyAndReturnArgs} args - Arguments to create many TipoEventos.
     * @example
     * // Create many TipoEventos
     * const tipoEvento = await prisma.tipoEvento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoEventos and only return the `id`
     * const tipoEventoWithIdOnly = await prisma.tipoEvento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoEventoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoEventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TipoEvento.
     * @param {TipoEventoDeleteArgs} args - Arguments to delete one TipoEvento.
     * @example
     * // Delete one TipoEvento
     * const TipoEvento = await prisma.tipoEvento.delete({
     *   where: {
     *     // ... filter to delete one TipoEvento
     *   }
     * })
     * 
     */
    delete<T extends TipoEventoDeleteArgs>(args: SelectSubset<T, TipoEventoDeleteArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TipoEvento.
     * @param {TipoEventoUpdateArgs} args - Arguments to update one TipoEvento.
     * @example
     * // Update one TipoEvento
     * const tipoEvento = await prisma.tipoEvento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoEventoUpdateArgs>(args: SelectSubset<T, TipoEventoUpdateArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TipoEventos.
     * @param {TipoEventoDeleteManyArgs} args - Arguments to filter TipoEventos to delete.
     * @example
     * // Delete a few TipoEventos
     * const { count } = await prisma.tipoEvento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoEventoDeleteManyArgs>(args?: SelectSubset<T, TipoEventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoEventos
     * const tipoEvento = await prisma.tipoEvento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoEventoUpdateManyArgs>(args: SelectSubset<T, TipoEventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TipoEvento.
     * @param {TipoEventoUpsertArgs} args - Arguments to update or create a TipoEvento.
     * @example
     * // Update or create a TipoEvento
     * const tipoEvento = await prisma.tipoEvento.upsert({
     *   create: {
     *     // ... data to create a TipoEvento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoEvento we want to update
     *   }
     * })
     */
    upsert<T extends TipoEventoUpsertArgs>(args: SelectSubset<T, TipoEventoUpsertArgs<ExtArgs>>): Prisma__TipoEventoClient<$Result.GetResult<Prisma.$TipoEventoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TipoEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEventoCountArgs} args - Arguments to filter TipoEventos to count.
     * @example
     * // Count the number of TipoEventos
     * const count = await prisma.tipoEvento.count({
     *   where: {
     *     // ... the filter for the TipoEventos we want to count
     *   }
     * })
    **/
    count<T extends TipoEventoCountArgs>(
      args?: Subset<T, TipoEventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoEventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoEventoAggregateArgs>(args: Subset<T, TipoEventoAggregateArgs>): Prisma.PrismaPromise<GetTipoEventoAggregateType<T>>

    /**
     * Group by TipoEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoEventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoEventoGroupByArgs['orderBy'] }
        : { orderBy?: TipoEventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoEventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoEventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoEvento model
   */
  readonly fields: TipoEventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoEvento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoEventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eventos<T extends TipoEvento$eventosArgs<ExtArgs> = {}>(args?: Subset<T, TipoEvento$eventosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoEvento model
   */ 
  interface TipoEventoFieldRefs {
    readonly id: FieldRef<"TipoEvento", 'String'>
    readonly nombre: FieldRef<"TipoEvento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TipoEvento findUnique
   */
  export type TipoEventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvento to fetch.
     */
    where: TipoEventoWhereUniqueInput
  }

  /**
   * TipoEvento findUniqueOrThrow
   */
  export type TipoEventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvento to fetch.
     */
    where: TipoEventoWhereUniqueInput
  }

  /**
   * TipoEvento findFirst
   */
  export type TipoEventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvento to fetch.
     */
    where?: TipoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEventos to fetch.
     */
    orderBy?: TipoEventoOrderByWithRelationInput | TipoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEventos.
     */
    cursor?: TipoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEventos.
     */
    distinct?: TipoEventoScalarFieldEnum | TipoEventoScalarFieldEnum[]
  }

  /**
   * TipoEvento findFirstOrThrow
   */
  export type TipoEventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * Filter, which TipoEvento to fetch.
     */
    where?: TipoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEventos to fetch.
     */
    orderBy?: TipoEventoOrderByWithRelationInput | TipoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEventos.
     */
    cursor?: TipoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEventos.
     */
    distinct?: TipoEventoScalarFieldEnum | TipoEventoScalarFieldEnum[]
  }

  /**
   * TipoEvento findMany
   */
  export type TipoEventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * Filter, which TipoEventos to fetch.
     */
    where?: TipoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEventos to fetch.
     */
    orderBy?: TipoEventoOrderByWithRelationInput | TipoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoEventos.
     */
    cursor?: TipoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEventos.
     */
    skip?: number
    distinct?: TipoEventoScalarFieldEnum | TipoEventoScalarFieldEnum[]
  }

  /**
   * TipoEvento create
   */
  export type TipoEventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoEvento.
     */
    data: XOR<TipoEventoCreateInput, TipoEventoUncheckedCreateInput>
  }

  /**
   * TipoEvento createMany
   */
  export type TipoEventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoEventos.
     */
    data: TipoEventoCreateManyInput | TipoEventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEvento createManyAndReturn
   */
  export type TipoEventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TipoEventos.
     */
    data: TipoEventoCreateManyInput | TipoEventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEvento update
   */
  export type TipoEventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoEvento.
     */
    data: XOR<TipoEventoUpdateInput, TipoEventoUncheckedUpdateInput>
    /**
     * Choose, which TipoEvento to update.
     */
    where: TipoEventoWhereUniqueInput
  }

  /**
   * TipoEvento updateMany
   */
  export type TipoEventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoEventos.
     */
    data: XOR<TipoEventoUpdateManyMutationInput, TipoEventoUncheckedUpdateManyInput>
    /**
     * Filter which TipoEventos to update
     */
    where?: TipoEventoWhereInput
  }

  /**
   * TipoEvento upsert
   */
  export type TipoEventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoEvento to update in case it exists.
     */
    where: TipoEventoWhereUniqueInput
    /**
     * In case the TipoEvento found by the `where` argument doesn't exist, create a new TipoEvento with this data.
     */
    create: XOR<TipoEventoCreateInput, TipoEventoUncheckedCreateInput>
    /**
     * In case the TipoEvento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoEventoUpdateInput, TipoEventoUncheckedUpdateInput>
  }

  /**
   * TipoEvento delete
   */
  export type TipoEventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
    /**
     * Filter which TipoEvento to delete.
     */
    where: TipoEventoWhereUniqueInput
  }

  /**
   * TipoEvento deleteMany
   */
  export type TipoEventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEventos to delete
     */
    where?: TipoEventoWhereInput
  }

  /**
   * TipoEvento.eventos
   */
  export type TipoEvento$eventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    cursor?: EventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * TipoEvento without action
   */
  export type TipoEventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEvento
     */
    select?: TipoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEventoInclude<ExtArgs> | null
  }


  /**
   * Model Empleada
   */

  export type AggregateEmpleada = {
    _count: EmpleadaCountAggregateOutputType | null
    _min: EmpleadaMinAggregateOutputType | null
    _max: EmpleadaMaxAggregateOutputType | null
  }

  export type EmpleadaMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    email: string | null
    telefono: string | null
  }

  export type EmpleadaMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    apellido: string | null
    dni: string | null
    email: string | null
    telefono: string | null
  }

  export type EmpleadaCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    dni: number
    email: number
    telefono: number
    _all: number
  }


  export type EmpleadaMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    email?: true
    telefono?: true
  }

  export type EmpleadaMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    email?: true
    telefono?: true
  }

  export type EmpleadaCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    dni?: true
    email?: true
    telefono?: true
    _all?: true
  }

  export type EmpleadaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empleada to aggregate.
     */
    where?: EmpleadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleadas to fetch.
     */
    orderBy?: EmpleadaOrderByWithRelationInput | EmpleadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpleadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empleadas
    **/
    _count?: true | EmpleadaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadaMaxAggregateInputType
  }

  export type GetEmpleadaAggregateType<T extends EmpleadaAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleada[P]>
      : GetScalarType<T[P], AggregateEmpleada[P]>
  }




  export type EmpleadaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpleadaWhereInput
    orderBy?: EmpleadaOrderByWithAggregationInput | EmpleadaOrderByWithAggregationInput[]
    by: EmpleadaScalarFieldEnum[] | EmpleadaScalarFieldEnum
    having?: EmpleadaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadaCountAggregateInputType | true
    _min?: EmpleadaMinAggregateInputType
    _max?: EmpleadaMaxAggregateInputType
  }

  export type EmpleadaGroupByOutputType = {
    id: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
    _count: EmpleadaCountAggregateOutputType | null
    _min: EmpleadaMinAggregateOutputType | null
    _max: EmpleadaMaxAggregateOutputType | null
  }

  type GetEmpleadaGroupByPayload<T extends EmpleadaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpleadaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadaGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadaGroupByOutputType[P]>
        }
      >
    >


  export type EmpleadaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    email?: boolean
    telefono?: boolean
    roles?: boolean | Empleada$rolesArgs<ExtArgs>
    eventos?: boolean | Empleada$eventosArgs<ExtArgs>
    _count?: boolean | EmpleadaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleada"]>

  export type EmpleadaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    email?: boolean
    telefono?: boolean
  }, ExtArgs["result"]["empleada"]>

  export type EmpleadaSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    dni?: boolean
    email?: boolean
    telefono?: boolean
  }

  export type EmpleadaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Empleada$rolesArgs<ExtArgs>
    eventos?: boolean | Empleada$eventosArgs<ExtArgs>
    _count?: boolean | EmpleadaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmpleadaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmpleadaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empleada"
    objects: {
      roles: Prisma.$EmpleadaRolPayload<ExtArgs>[]
      eventos: Prisma.$EventoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      apellido: string
      dni: string
      email: string
      telefono: string
    }, ExtArgs["result"]["empleada"]>
    composites: {}
  }

  type EmpleadaGetPayload<S extends boolean | null | undefined | EmpleadaDefaultArgs> = $Result.GetResult<Prisma.$EmpleadaPayload, S>

  type EmpleadaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpleadaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpleadaCountAggregateInputType | true
    }

  export interface EmpleadaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empleada'], meta: { name: 'Empleada' } }
    /**
     * Find zero or one Empleada that matches the filter.
     * @param {EmpleadaFindUniqueArgs} args - Arguments to find a Empleada
     * @example
     * // Get one Empleada
     * const empleada = await prisma.empleada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpleadaFindUniqueArgs>(args: SelectSubset<T, EmpleadaFindUniqueArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Empleada that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpleadaFindUniqueOrThrowArgs} args - Arguments to find a Empleada
     * @example
     * // Get one Empleada
     * const empleada = await prisma.empleada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpleadaFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpleadaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Empleada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaFindFirstArgs} args - Arguments to find a Empleada
     * @example
     * // Get one Empleada
     * const empleada = await prisma.empleada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpleadaFindFirstArgs>(args?: SelectSubset<T, EmpleadaFindFirstArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Empleada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaFindFirstOrThrowArgs} args - Arguments to find a Empleada
     * @example
     * // Get one Empleada
     * const empleada = await prisma.empleada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpleadaFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpleadaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Empleadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleadas
     * const empleadas = await prisma.empleada.findMany()
     * 
     * // Get first 10 Empleadas
     * const empleadas = await prisma.empleada.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empleadaWithIdOnly = await prisma.empleada.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpleadaFindManyArgs>(args?: SelectSubset<T, EmpleadaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Empleada.
     * @param {EmpleadaCreateArgs} args - Arguments to create a Empleada.
     * @example
     * // Create one Empleada
     * const Empleada = await prisma.empleada.create({
     *   data: {
     *     // ... data to create a Empleada
     *   }
     * })
     * 
     */
    create<T extends EmpleadaCreateArgs>(args: SelectSubset<T, EmpleadaCreateArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Empleadas.
     * @param {EmpleadaCreateManyArgs} args - Arguments to create many Empleadas.
     * @example
     * // Create many Empleadas
     * const empleada = await prisma.empleada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpleadaCreateManyArgs>(args?: SelectSubset<T, EmpleadaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Empleadas and returns the data saved in the database.
     * @param {EmpleadaCreateManyAndReturnArgs} args - Arguments to create many Empleadas.
     * @example
     * // Create many Empleadas
     * const empleada = await prisma.empleada.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Empleadas and only return the `id`
     * const empleadaWithIdOnly = await prisma.empleada.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpleadaCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpleadaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Empleada.
     * @param {EmpleadaDeleteArgs} args - Arguments to delete one Empleada.
     * @example
     * // Delete one Empleada
     * const Empleada = await prisma.empleada.delete({
     *   where: {
     *     // ... filter to delete one Empleada
     *   }
     * })
     * 
     */
    delete<T extends EmpleadaDeleteArgs>(args: SelectSubset<T, EmpleadaDeleteArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Empleada.
     * @param {EmpleadaUpdateArgs} args - Arguments to update one Empleada.
     * @example
     * // Update one Empleada
     * const empleada = await prisma.empleada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpleadaUpdateArgs>(args: SelectSubset<T, EmpleadaUpdateArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Empleadas.
     * @param {EmpleadaDeleteManyArgs} args - Arguments to filter Empleadas to delete.
     * @example
     * // Delete a few Empleadas
     * const { count } = await prisma.empleada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpleadaDeleteManyArgs>(args?: SelectSubset<T, EmpleadaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleadas
     * const empleada = await prisma.empleada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpleadaUpdateManyArgs>(args: SelectSubset<T, EmpleadaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleada.
     * @param {EmpleadaUpsertArgs} args - Arguments to update or create a Empleada.
     * @example
     * // Update or create a Empleada
     * const empleada = await prisma.empleada.upsert({
     *   create: {
     *     // ... data to create a Empleada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleada we want to update
     *   }
     * })
     */
    upsert<T extends EmpleadaUpsertArgs>(args: SelectSubset<T, EmpleadaUpsertArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Empleadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaCountArgs} args - Arguments to filter Empleadas to count.
     * @example
     * // Count the number of Empleadas
     * const count = await prisma.empleada.count({
     *   where: {
     *     // ... the filter for the Empleadas we want to count
     *   }
     * })
    **/
    count<T extends EmpleadaCountArgs>(
      args?: Subset<T, EmpleadaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadaAggregateArgs>(args: Subset<T, EmpleadaAggregateArgs>): Prisma.PrismaPromise<GetEmpleadaAggregateType<T>>

    /**
     * Group by Empleada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadaGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empleada model
   */
  readonly fields: EmpleadaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empleada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpleadaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Empleada$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Empleada$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "findMany"> | Null>
    eventos<T extends Empleada$eventosArgs<ExtArgs> = {}>(args?: Subset<T, Empleada$eventosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Empleada model
   */ 
  interface EmpleadaFieldRefs {
    readonly id: FieldRef<"Empleada", 'String'>
    readonly nombre: FieldRef<"Empleada", 'String'>
    readonly apellido: FieldRef<"Empleada", 'String'>
    readonly dni: FieldRef<"Empleada", 'String'>
    readonly email: FieldRef<"Empleada", 'String'>
    readonly telefono: FieldRef<"Empleada", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Empleada findUnique
   */
  export type EmpleadaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * Filter, which Empleada to fetch.
     */
    where: EmpleadaWhereUniqueInput
  }

  /**
   * Empleada findUniqueOrThrow
   */
  export type EmpleadaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * Filter, which Empleada to fetch.
     */
    where: EmpleadaWhereUniqueInput
  }

  /**
   * Empleada findFirst
   */
  export type EmpleadaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * Filter, which Empleada to fetch.
     */
    where?: EmpleadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleadas to fetch.
     */
    orderBy?: EmpleadaOrderByWithRelationInput | EmpleadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empleadas.
     */
    cursor?: EmpleadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empleadas.
     */
    distinct?: EmpleadaScalarFieldEnum | EmpleadaScalarFieldEnum[]
  }

  /**
   * Empleada findFirstOrThrow
   */
  export type EmpleadaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * Filter, which Empleada to fetch.
     */
    where?: EmpleadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleadas to fetch.
     */
    orderBy?: EmpleadaOrderByWithRelationInput | EmpleadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empleadas.
     */
    cursor?: EmpleadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empleadas.
     */
    distinct?: EmpleadaScalarFieldEnum | EmpleadaScalarFieldEnum[]
  }

  /**
   * Empleada findMany
   */
  export type EmpleadaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * Filter, which Empleadas to fetch.
     */
    where?: EmpleadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleadas to fetch.
     */
    orderBy?: EmpleadaOrderByWithRelationInput | EmpleadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empleadas.
     */
    cursor?: EmpleadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleadas.
     */
    skip?: number
    distinct?: EmpleadaScalarFieldEnum | EmpleadaScalarFieldEnum[]
  }

  /**
   * Empleada create
   */
  export type EmpleadaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * The data needed to create a Empleada.
     */
    data: XOR<EmpleadaCreateInput, EmpleadaUncheckedCreateInput>
  }

  /**
   * Empleada createMany
   */
  export type EmpleadaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empleadas.
     */
    data: EmpleadaCreateManyInput | EmpleadaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empleada createManyAndReturn
   */
  export type EmpleadaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Empleadas.
     */
    data: EmpleadaCreateManyInput | EmpleadaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Empleada update
   */
  export type EmpleadaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * The data needed to update a Empleada.
     */
    data: XOR<EmpleadaUpdateInput, EmpleadaUncheckedUpdateInput>
    /**
     * Choose, which Empleada to update.
     */
    where: EmpleadaWhereUniqueInput
  }

  /**
   * Empleada updateMany
   */
  export type EmpleadaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empleadas.
     */
    data: XOR<EmpleadaUpdateManyMutationInput, EmpleadaUncheckedUpdateManyInput>
    /**
     * Filter which Empleadas to update
     */
    where?: EmpleadaWhereInput
  }

  /**
   * Empleada upsert
   */
  export type EmpleadaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * The filter to search for the Empleada to update in case it exists.
     */
    where: EmpleadaWhereUniqueInput
    /**
     * In case the Empleada found by the `where` argument doesn't exist, create a new Empleada with this data.
     */
    create: XOR<EmpleadaCreateInput, EmpleadaUncheckedCreateInput>
    /**
     * In case the Empleada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpleadaUpdateInput, EmpleadaUncheckedUpdateInput>
  }

  /**
   * Empleada delete
   */
  export type EmpleadaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
    /**
     * Filter which Empleada to delete.
     */
    where: EmpleadaWhereUniqueInput
  }

  /**
   * Empleada deleteMany
   */
  export type EmpleadaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empleadas to delete
     */
    where?: EmpleadaWhereInput
  }

  /**
   * Empleada.roles
   */
  export type Empleada$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    where?: EmpleadaRolWhereInput
    orderBy?: EmpleadaRolOrderByWithRelationInput | EmpleadaRolOrderByWithRelationInput[]
    cursor?: EmpleadaRolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmpleadaRolScalarFieldEnum | EmpleadaRolScalarFieldEnum[]
  }

  /**
   * Empleada.eventos
   */
  export type Empleada$eventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    cursor?: EventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Empleada without action
   */
  export type EmpleadaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleada
     */
    select?: EmpleadaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaInclude<ExtArgs> | null
  }


  /**
   * Model EmpleadaRol
   */

  export type AggregateEmpleadaRol = {
    _count: EmpleadaRolCountAggregateOutputType | null
    _min: EmpleadaRolMinAggregateOutputType | null
    _max: EmpleadaRolMaxAggregateOutputType | null
  }

  export type EmpleadaRolMinAggregateOutputType = {
    id: string | null
    empleadaId: string | null
    rol: $Enums.RolEmpleada | null
  }

  export type EmpleadaRolMaxAggregateOutputType = {
    id: string | null
    empleadaId: string | null
    rol: $Enums.RolEmpleada | null
  }

  export type EmpleadaRolCountAggregateOutputType = {
    id: number
    empleadaId: number
    rol: number
    _all: number
  }


  export type EmpleadaRolMinAggregateInputType = {
    id?: true
    empleadaId?: true
    rol?: true
  }

  export type EmpleadaRolMaxAggregateInputType = {
    id?: true
    empleadaId?: true
    rol?: true
  }

  export type EmpleadaRolCountAggregateInputType = {
    id?: true
    empleadaId?: true
    rol?: true
    _all?: true
  }

  export type EmpleadaRolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmpleadaRol to aggregate.
     */
    where?: EmpleadaRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpleadaRols to fetch.
     */
    orderBy?: EmpleadaRolOrderByWithRelationInput | EmpleadaRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpleadaRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpleadaRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpleadaRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmpleadaRols
    **/
    _count?: true | EmpleadaRolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadaRolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadaRolMaxAggregateInputType
  }

  export type GetEmpleadaRolAggregateType<T extends EmpleadaRolAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleadaRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleadaRol[P]>
      : GetScalarType<T[P], AggregateEmpleadaRol[P]>
  }




  export type EmpleadaRolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpleadaRolWhereInput
    orderBy?: EmpleadaRolOrderByWithAggregationInput | EmpleadaRolOrderByWithAggregationInput[]
    by: EmpleadaRolScalarFieldEnum[] | EmpleadaRolScalarFieldEnum
    having?: EmpleadaRolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadaRolCountAggregateInputType | true
    _min?: EmpleadaRolMinAggregateInputType
    _max?: EmpleadaRolMaxAggregateInputType
  }

  export type EmpleadaRolGroupByOutputType = {
    id: string
    empleadaId: string
    rol: $Enums.RolEmpleada
    _count: EmpleadaRolCountAggregateOutputType | null
    _min: EmpleadaRolMinAggregateOutputType | null
    _max: EmpleadaRolMaxAggregateOutputType | null
  }

  type GetEmpleadaRolGroupByPayload<T extends EmpleadaRolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpleadaRolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadaRolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadaRolGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadaRolGroupByOutputType[P]>
        }
      >
    >


  export type EmpleadaRolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empleadaId?: boolean
    rol?: boolean
    empleada?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleadaRol"]>

  export type EmpleadaRolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    empleadaId?: boolean
    rol?: boolean
    empleada?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleadaRol"]>

  export type EmpleadaRolSelectScalar = {
    id?: boolean
    empleadaId?: boolean
    rol?: boolean
  }

  export type EmpleadaRolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleada?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }
  export type EmpleadaRolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleada?: boolean | EmpleadaDefaultArgs<ExtArgs>
  }

  export type $EmpleadaRolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmpleadaRol"
    objects: {
      empleada: Prisma.$EmpleadaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      empleadaId: string
      rol: $Enums.RolEmpleada
    }, ExtArgs["result"]["empleadaRol"]>
    composites: {}
  }

  type EmpleadaRolGetPayload<S extends boolean | null | undefined | EmpleadaRolDefaultArgs> = $Result.GetResult<Prisma.$EmpleadaRolPayload, S>

  type EmpleadaRolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpleadaRolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpleadaRolCountAggregateInputType | true
    }

  export interface EmpleadaRolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmpleadaRol'], meta: { name: 'EmpleadaRol' } }
    /**
     * Find zero or one EmpleadaRol that matches the filter.
     * @param {EmpleadaRolFindUniqueArgs} args - Arguments to find a EmpleadaRol
     * @example
     * // Get one EmpleadaRol
     * const empleadaRol = await prisma.empleadaRol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmpleadaRolFindUniqueArgs>(args: SelectSubset<T, EmpleadaRolFindUniqueArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmpleadaRol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmpleadaRolFindUniqueOrThrowArgs} args - Arguments to find a EmpleadaRol
     * @example
     * // Get one EmpleadaRol
     * const empleadaRol = await prisma.empleadaRol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmpleadaRolFindUniqueOrThrowArgs>(args: SelectSubset<T, EmpleadaRolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmpleadaRol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaRolFindFirstArgs} args - Arguments to find a EmpleadaRol
     * @example
     * // Get one EmpleadaRol
     * const empleadaRol = await prisma.empleadaRol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmpleadaRolFindFirstArgs>(args?: SelectSubset<T, EmpleadaRolFindFirstArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmpleadaRol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaRolFindFirstOrThrowArgs} args - Arguments to find a EmpleadaRol
     * @example
     * // Get one EmpleadaRol
     * const empleadaRol = await prisma.empleadaRol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmpleadaRolFindFirstOrThrowArgs>(args?: SelectSubset<T, EmpleadaRolFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmpleadaRols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaRolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmpleadaRols
     * const empleadaRols = await prisma.empleadaRol.findMany()
     * 
     * // Get first 10 EmpleadaRols
     * const empleadaRols = await prisma.empleadaRol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empleadaRolWithIdOnly = await prisma.empleadaRol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmpleadaRolFindManyArgs>(args?: SelectSubset<T, EmpleadaRolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmpleadaRol.
     * @param {EmpleadaRolCreateArgs} args - Arguments to create a EmpleadaRol.
     * @example
     * // Create one EmpleadaRol
     * const EmpleadaRol = await prisma.empleadaRol.create({
     *   data: {
     *     // ... data to create a EmpleadaRol
     *   }
     * })
     * 
     */
    create<T extends EmpleadaRolCreateArgs>(args: SelectSubset<T, EmpleadaRolCreateArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmpleadaRols.
     * @param {EmpleadaRolCreateManyArgs} args - Arguments to create many EmpleadaRols.
     * @example
     * // Create many EmpleadaRols
     * const empleadaRol = await prisma.empleadaRol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmpleadaRolCreateManyArgs>(args?: SelectSubset<T, EmpleadaRolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmpleadaRols and returns the data saved in the database.
     * @param {EmpleadaRolCreateManyAndReturnArgs} args - Arguments to create many EmpleadaRols.
     * @example
     * // Create many EmpleadaRols
     * const empleadaRol = await prisma.empleadaRol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmpleadaRols and only return the `id`
     * const empleadaRolWithIdOnly = await prisma.empleadaRol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmpleadaRolCreateManyAndReturnArgs>(args?: SelectSubset<T, EmpleadaRolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmpleadaRol.
     * @param {EmpleadaRolDeleteArgs} args - Arguments to delete one EmpleadaRol.
     * @example
     * // Delete one EmpleadaRol
     * const EmpleadaRol = await prisma.empleadaRol.delete({
     *   where: {
     *     // ... filter to delete one EmpleadaRol
     *   }
     * })
     * 
     */
    delete<T extends EmpleadaRolDeleteArgs>(args: SelectSubset<T, EmpleadaRolDeleteArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmpleadaRol.
     * @param {EmpleadaRolUpdateArgs} args - Arguments to update one EmpleadaRol.
     * @example
     * // Update one EmpleadaRol
     * const empleadaRol = await prisma.empleadaRol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmpleadaRolUpdateArgs>(args: SelectSubset<T, EmpleadaRolUpdateArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmpleadaRols.
     * @param {EmpleadaRolDeleteManyArgs} args - Arguments to filter EmpleadaRols to delete.
     * @example
     * // Delete a few EmpleadaRols
     * const { count } = await prisma.empleadaRol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmpleadaRolDeleteManyArgs>(args?: SelectSubset<T, EmpleadaRolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmpleadaRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaRolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmpleadaRols
     * const empleadaRol = await prisma.empleadaRol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmpleadaRolUpdateManyArgs>(args: SelectSubset<T, EmpleadaRolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmpleadaRol.
     * @param {EmpleadaRolUpsertArgs} args - Arguments to update or create a EmpleadaRol.
     * @example
     * // Update or create a EmpleadaRol
     * const empleadaRol = await prisma.empleadaRol.upsert({
     *   create: {
     *     // ... data to create a EmpleadaRol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmpleadaRol we want to update
     *   }
     * })
     */
    upsert<T extends EmpleadaRolUpsertArgs>(args: SelectSubset<T, EmpleadaRolUpsertArgs<ExtArgs>>): Prisma__EmpleadaRolClient<$Result.GetResult<Prisma.$EmpleadaRolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmpleadaRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaRolCountArgs} args - Arguments to filter EmpleadaRols to count.
     * @example
     * // Count the number of EmpleadaRols
     * const count = await prisma.empleadaRol.count({
     *   where: {
     *     // ... the filter for the EmpleadaRols we want to count
     *   }
     * })
    **/
    count<T extends EmpleadaRolCountArgs>(
      args?: Subset<T, EmpleadaRolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadaRolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmpleadaRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaRolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadaRolAggregateArgs>(args: Subset<T, EmpleadaRolAggregateArgs>): Prisma.PrismaPromise<GetEmpleadaRolAggregateType<T>>

    /**
     * Group by EmpleadaRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadaRolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadaRolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadaRolGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadaRolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadaRolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadaRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmpleadaRol model
   */
  readonly fields: EmpleadaRolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmpleadaRol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpleadaRolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    empleada<T extends EmpleadaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmpleadaDefaultArgs<ExtArgs>>): Prisma__EmpleadaClient<$Result.GetResult<Prisma.$EmpleadaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmpleadaRol model
   */ 
  interface EmpleadaRolFieldRefs {
    readonly id: FieldRef<"EmpleadaRol", 'String'>
    readonly empleadaId: FieldRef<"EmpleadaRol", 'String'>
    readonly rol: FieldRef<"EmpleadaRol", 'RolEmpleada'>
  }
    

  // Custom InputTypes
  /**
   * EmpleadaRol findUnique
   */
  export type EmpleadaRolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * Filter, which EmpleadaRol to fetch.
     */
    where: EmpleadaRolWhereUniqueInput
  }

  /**
   * EmpleadaRol findUniqueOrThrow
   */
  export type EmpleadaRolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * Filter, which EmpleadaRol to fetch.
     */
    where: EmpleadaRolWhereUniqueInput
  }

  /**
   * EmpleadaRol findFirst
   */
  export type EmpleadaRolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * Filter, which EmpleadaRol to fetch.
     */
    where?: EmpleadaRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpleadaRols to fetch.
     */
    orderBy?: EmpleadaRolOrderByWithRelationInput | EmpleadaRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmpleadaRols.
     */
    cursor?: EmpleadaRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpleadaRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpleadaRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmpleadaRols.
     */
    distinct?: EmpleadaRolScalarFieldEnum | EmpleadaRolScalarFieldEnum[]
  }

  /**
   * EmpleadaRol findFirstOrThrow
   */
  export type EmpleadaRolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * Filter, which EmpleadaRol to fetch.
     */
    where?: EmpleadaRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpleadaRols to fetch.
     */
    orderBy?: EmpleadaRolOrderByWithRelationInput | EmpleadaRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmpleadaRols.
     */
    cursor?: EmpleadaRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpleadaRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpleadaRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmpleadaRols.
     */
    distinct?: EmpleadaRolScalarFieldEnum | EmpleadaRolScalarFieldEnum[]
  }

  /**
   * EmpleadaRol findMany
   */
  export type EmpleadaRolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * Filter, which EmpleadaRols to fetch.
     */
    where?: EmpleadaRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmpleadaRols to fetch.
     */
    orderBy?: EmpleadaRolOrderByWithRelationInput | EmpleadaRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmpleadaRols.
     */
    cursor?: EmpleadaRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmpleadaRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmpleadaRols.
     */
    skip?: number
    distinct?: EmpleadaRolScalarFieldEnum | EmpleadaRolScalarFieldEnum[]
  }

  /**
   * EmpleadaRol create
   */
  export type EmpleadaRolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * The data needed to create a EmpleadaRol.
     */
    data: XOR<EmpleadaRolCreateInput, EmpleadaRolUncheckedCreateInput>
  }

  /**
   * EmpleadaRol createMany
   */
  export type EmpleadaRolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmpleadaRols.
     */
    data: EmpleadaRolCreateManyInput | EmpleadaRolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmpleadaRol createManyAndReturn
   */
  export type EmpleadaRolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmpleadaRols.
     */
    data: EmpleadaRolCreateManyInput | EmpleadaRolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmpleadaRol update
   */
  export type EmpleadaRolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * The data needed to update a EmpleadaRol.
     */
    data: XOR<EmpleadaRolUpdateInput, EmpleadaRolUncheckedUpdateInput>
    /**
     * Choose, which EmpleadaRol to update.
     */
    where: EmpleadaRolWhereUniqueInput
  }

  /**
   * EmpleadaRol updateMany
   */
  export type EmpleadaRolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmpleadaRols.
     */
    data: XOR<EmpleadaRolUpdateManyMutationInput, EmpleadaRolUncheckedUpdateManyInput>
    /**
     * Filter which EmpleadaRols to update
     */
    where?: EmpleadaRolWhereInput
  }

  /**
   * EmpleadaRol upsert
   */
  export type EmpleadaRolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * The filter to search for the EmpleadaRol to update in case it exists.
     */
    where: EmpleadaRolWhereUniqueInput
    /**
     * In case the EmpleadaRol found by the `where` argument doesn't exist, create a new EmpleadaRol with this data.
     */
    create: XOR<EmpleadaRolCreateInput, EmpleadaRolUncheckedCreateInput>
    /**
     * In case the EmpleadaRol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpleadaRolUpdateInput, EmpleadaRolUncheckedUpdateInput>
  }

  /**
   * EmpleadaRol delete
   */
  export type EmpleadaRolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
    /**
     * Filter which EmpleadaRol to delete.
     */
    where: EmpleadaRolWhereUniqueInput
  }

  /**
   * EmpleadaRol deleteMany
   */
  export type EmpleadaRolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmpleadaRols to delete
     */
    where?: EmpleadaRolWhereInput
  }

  /**
   * EmpleadaRol without action
   */
  export type EmpleadaRolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadaRol
     */
    select?: EmpleadaRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmpleadaRolInclude<ExtArgs> | null
  }


  /**
   * Model Movimiento
   */

  export type AggregateMovimiento = {
    _count: MovimientoCountAggregateOutputType | null
    _avg: MovimientoAvgAggregateOutputType | null
    _sum: MovimientoSumAggregateOutputType | null
    _min: MovimientoMinAggregateOutputType | null
    _max: MovimientoMaxAggregateOutputType | null
  }

  export type MovimientoAvgAggregateOutputType = {
    monto: number | null
  }

  export type MovimientoSumAggregateOutputType = {
    monto: number | null
  }

  export type MovimientoMinAggregateOutputType = {
    id: string | null
    monto: number | null
    moneda: $Enums.Moneda | null
    categoriaId: string | null
    subcategoriaId: string | null
    detalleId: string | null
    ingreso: boolean | null
    fechaProgramado: Date | null
    fechaRecibido: Date | null
  }

  export type MovimientoMaxAggregateOutputType = {
    id: string | null
    monto: number | null
    moneda: $Enums.Moneda | null
    categoriaId: string | null
    subcategoriaId: string | null
    detalleId: string | null
    ingreso: boolean | null
    fechaProgramado: Date | null
    fechaRecibido: Date | null
  }

  export type MovimientoCountAggregateOutputType = {
    id: number
    monto: number
    moneda: number
    categoriaId: number
    subcategoriaId: number
    detalleId: number
    ingreso: number
    fechaProgramado: number
    fechaRecibido: number
    _all: number
  }


  export type MovimientoAvgAggregateInputType = {
    monto?: true
  }

  export type MovimientoSumAggregateInputType = {
    monto?: true
  }

  export type MovimientoMinAggregateInputType = {
    id?: true
    monto?: true
    moneda?: true
    categoriaId?: true
    subcategoriaId?: true
    detalleId?: true
    ingreso?: true
    fechaProgramado?: true
    fechaRecibido?: true
  }

  export type MovimientoMaxAggregateInputType = {
    id?: true
    monto?: true
    moneda?: true
    categoriaId?: true
    subcategoriaId?: true
    detalleId?: true
    ingreso?: true
    fechaProgramado?: true
    fechaRecibido?: true
  }

  export type MovimientoCountAggregateInputType = {
    id?: true
    monto?: true
    moneda?: true
    categoriaId?: true
    subcategoriaId?: true
    detalleId?: true
    ingreso?: true
    fechaProgramado?: true
    fechaRecibido?: true
    _all?: true
  }

  export type MovimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movimiento to aggregate.
     */
    where?: MovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movimientos to fetch.
     */
    orderBy?: MovimientoOrderByWithRelationInput | MovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Movimientos
    **/
    _count?: true | MovimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MovimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MovimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovimientoMaxAggregateInputType
  }

  export type GetMovimientoAggregateType<T extends MovimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateMovimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovimiento[P]>
      : GetScalarType<T[P], AggregateMovimiento[P]>
  }




  export type MovimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MovimientoWhereInput
    orderBy?: MovimientoOrderByWithAggregationInput | MovimientoOrderByWithAggregationInput[]
    by: MovimientoScalarFieldEnum[] | MovimientoScalarFieldEnum
    having?: MovimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovimientoCountAggregateInputType | true
    _avg?: MovimientoAvgAggregateInputType
    _sum?: MovimientoSumAggregateInputType
    _min?: MovimientoMinAggregateInputType
    _max?: MovimientoMaxAggregateInputType
  }

  export type MovimientoGroupByOutputType = {
    id: string
    monto: number
    moneda: $Enums.Moneda
    categoriaId: string
    subcategoriaId: string
    detalleId: string
    ingreso: boolean
    fechaProgramado: Date
    fechaRecibido: Date | null
    _count: MovimientoCountAggregateOutputType | null
    _avg: MovimientoAvgAggregateOutputType | null
    _sum: MovimientoSumAggregateOutputType | null
    _min: MovimientoMinAggregateOutputType | null
    _max: MovimientoMaxAggregateOutputType | null
  }

  type GetMovimientoGroupByPayload<T extends MovimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MovimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovimientoGroupByOutputType[P]>
            : GetScalarType<T[P], MovimientoGroupByOutputType[P]>
        }
      >
    >


  export type MovimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monto?: boolean
    moneda?: boolean
    categoriaId?: boolean
    subcategoriaId?: boolean
    detalleId?: boolean
    ingreso?: boolean
    fechaProgramado?: boolean
    fechaRecibido?: boolean
    categoria?: boolean | CatMovDefaultArgs<ExtArgs>
    subcategoria?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
    detalle?: boolean | DetMovDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movimiento"]>

  export type MovimientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monto?: boolean
    moneda?: boolean
    categoriaId?: boolean
    subcategoriaId?: boolean
    detalleId?: boolean
    ingreso?: boolean
    fechaProgramado?: boolean
    fechaRecibido?: boolean
    categoria?: boolean | CatMovDefaultArgs<ExtArgs>
    subcategoria?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
    detalle?: boolean | DetMovDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["movimiento"]>

  export type MovimientoSelectScalar = {
    id?: boolean
    monto?: boolean
    moneda?: boolean
    categoriaId?: boolean
    subcategoriaId?: boolean
    detalleId?: boolean
    ingreso?: boolean
    fechaProgramado?: boolean
    fechaRecibido?: boolean
  }

  export type MovimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | CatMovDefaultArgs<ExtArgs>
    subcategoria?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
    detalle?: boolean | DetMovDefaultArgs<ExtArgs>
  }
  export type MovimientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categoria?: boolean | CatMovDefaultArgs<ExtArgs>
    subcategoria?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
    detalle?: boolean | DetMovDefaultArgs<ExtArgs>
  }

  export type $MovimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Movimiento"
    objects: {
      categoria: Prisma.$CatMovPayload<ExtArgs>
      subcategoria: Prisma.$SubcatMovimientoPayload<ExtArgs>
      detalle: Prisma.$DetMovPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monto: number
      moneda: $Enums.Moneda
      categoriaId: string
      subcategoriaId: string
      detalleId: string
      ingreso: boolean
      fechaProgramado: Date
      fechaRecibido: Date | null
    }, ExtArgs["result"]["movimiento"]>
    composites: {}
  }

  type MovimientoGetPayload<S extends boolean | null | undefined | MovimientoDefaultArgs> = $Result.GetResult<Prisma.$MovimientoPayload, S>

  type MovimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MovimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MovimientoCountAggregateInputType | true
    }

  export interface MovimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Movimiento'], meta: { name: 'Movimiento' } }
    /**
     * Find zero or one Movimiento that matches the filter.
     * @param {MovimientoFindUniqueArgs} args - Arguments to find a Movimiento
     * @example
     * // Get one Movimiento
     * const movimiento = await prisma.movimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MovimientoFindUniqueArgs>(args: SelectSubset<T, MovimientoFindUniqueArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Movimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MovimientoFindUniqueOrThrowArgs} args - Arguments to find a Movimiento
     * @example
     * // Get one Movimiento
     * const movimiento = await prisma.movimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MovimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, MovimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Movimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoFindFirstArgs} args - Arguments to find a Movimiento
     * @example
     * // Get one Movimiento
     * const movimiento = await prisma.movimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MovimientoFindFirstArgs>(args?: SelectSubset<T, MovimientoFindFirstArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Movimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoFindFirstOrThrowArgs} args - Arguments to find a Movimiento
     * @example
     * // Get one Movimiento
     * const movimiento = await prisma.movimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MovimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, MovimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Movimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movimientos
     * const movimientos = await prisma.movimiento.findMany()
     * 
     * // Get first 10 Movimientos
     * const movimientos = await prisma.movimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movimientoWithIdOnly = await prisma.movimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MovimientoFindManyArgs>(args?: SelectSubset<T, MovimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Movimiento.
     * @param {MovimientoCreateArgs} args - Arguments to create a Movimiento.
     * @example
     * // Create one Movimiento
     * const Movimiento = await prisma.movimiento.create({
     *   data: {
     *     // ... data to create a Movimiento
     *   }
     * })
     * 
     */
    create<T extends MovimientoCreateArgs>(args: SelectSubset<T, MovimientoCreateArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Movimientos.
     * @param {MovimientoCreateManyArgs} args - Arguments to create many Movimientos.
     * @example
     * // Create many Movimientos
     * const movimiento = await prisma.movimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MovimientoCreateManyArgs>(args?: SelectSubset<T, MovimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Movimientos and returns the data saved in the database.
     * @param {MovimientoCreateManyAndReturnArgs} args - Arguments to create many Movimientos.
     * @example
     * // Create many Movimientos
     * const movimiento = await prisma.movimiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Movimientos and only return the `id`
     * const movimientoWithIdOnly = await prisma.movimiento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MovimientoCreateManyAndReturnArgs>(args?: SelectSubset<T, MovimientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Movimiento.
     * @param {MovimientoDeleteArgs} args - Arguments to delete one Movimiento.
     * @example
     * // Delete one Movimiento
     * const Movimiento = await prisma.movimiento.delete({
     *   where: {
     *     // ... filter to delete one Movimiento
     *   }
     * })
     * 
     */
    delete<T extends MovimientoDeleteArgs>(args: SelectSubset<T, MovimientoDeleteArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Movimiento.
     * @param {MovimientoUpdateArgs} args - Arguments to update one Movimiento.
     * @example
     * // Update one Movimiento
     * const movimiento = await prisma.movimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MovimientoUpdateArgs>(args: SelectSubset<T, MovimientoUpdateArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Movimientos.
     * @param {MovimientoDeleteManyArgs} args - Arguments to filter Movimientos to delete.
     * @example
     * // Delete a few Movimientos
     * const { count } = await prisma.movimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MovimientoDeleteManyArgs>(args?: SelectSubset<T, MovimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movimientos
     * const movimiento = await prisma.movimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MovimientoUpdateManyArgs>(args: SelectSubset<T, MovimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movimiento.
     * @param {MovimientoUpsertArgs} args - Arguments to update or create a Movimiento.
     * @example
     * // Update or create a Movimiento
     * const movimiento = await prisma.movimiento.upsert({
     *   create: {
     *     // ... data to create a Movimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movimiento we want to update
     *   }
     * })
     */
    upsert<T extends MovimientoUpsertArgs>(args: SelectSubset<T, MovimientoUpsertArgs<ExtArgs>>): Prisma__MovimientoClient<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Movimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoCountArgs} args - Arguments to filter Movimientos to count.
     * @example
     * // Count the number of Movimientos
     * const count = await prisma.movimiento.count({
     *   where: {
     *     // ... the filter for the Movimientos we want to count
     *   }
     * })
    **/
    count<T extends MovimientoCountArgs>(
      args?: Subset<T, MovimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovimientoAggregateArgs>(args: Subset<T, MovimientoAggregateArgs>): Prisma.PrismaPromise<GetMovimientoAggregateType<T>>

    /**
     * Group by Movimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovimientoGroupByArgs['orderBy'] }
        : { orderBy?: MovimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Movimiento model
   */
  readonly fields: MovimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Movimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MovimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categoria<T extends CatMovDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatMovDefaultArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subcategoria<T extends SubcatMovimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubcatMovimientoDefaultArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    detalle<T extends DetMovDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DetMovDefaultArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Movimiento model
   */ 
  interface MovimientoFieldRefs {
    readonly id: FieldRef<"Movimiento", 'String'>
    readonly monto: FieldRef<"Movimiento", 'Float'>
    readonly moneda: FieldRef<"Movimiento", 'Moneda'>
    readonly categoriaId: FieldRef<"Movimiento", 'String'>
    readonly subcategoriaId: FieldRef<"Movimiento", 'String'>
    readonly detalleId: FieldRef<"Movimiento", 'String'>
    readonly ingreso: FieldRef<"Movimiento", 'Boolean'>
    readonly fechaProgramado: FieldRef<"Movimiento", 'DateTime'>
    readonly fechaRecibido: FieldRef<"Movimiento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Movimiento findUnique
   */
  export type MovimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * Filter, which Movimiento to fetch.
     */
    where: MovimientoWhereUniqueInput
  }

  /**
   * Movimiento findUniqueOrThrow
   */
  export type MovimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * Filter, which Movimiento to fetch.
     */
    where: MovimientoWhereUniqueInput
  }

  /**
   * Movimiento findFirst
   */
  export type MovimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * Filter, which Movimiento to fetch.
     */
    where?: MovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movimientos to fetch.
     */
    orderBy?: MovimientoOrderByWithRelationInput | MovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movimientos.
     */
    cursor?: MovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movimientos.
     */
    distinct?: MovimientoScalarFieldEnum | MovimientoScalarFieldEnum[]
  }

  /**
   * Movimiento findFirstOrThrow
   */
  export type MovimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * Filter, which Movimiento to fetch.
     */
    where?: MovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movimientos to fetch.
     */
    orderBy?: MovimientoOrderByWithRelationInput | MovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Movimientos.
     */
    cursor?: MovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Movimientos.
     */
    distinct?: MovimientoScalarFieldEnum | MovimientoScalarFieldEnum[]
  }

  /**
   * Movimiento findMany
   */
  export type MovimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * Filter, which Movimientos to fetch.
     */
    where?: MovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Movimientos to fetch.
     */
    orderBy?: MovimientoOrderByWithRelationInput | MovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Movimientos.
     */
    cursor?: MovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Movimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Movimientos.
     */
    skip?: number
    distinct?: MovimientoScalarFieldEnum | MovimientoScalarFieldEnum[]
  }

  /**
   * Movimiento create
   */
  export type MovimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Movimiento.
     */
    data: XOR<MovimientoCreateInput, MovimientoUncheckedCreateInput>
  }

  /**
   * Movimiento createMany
   */
  export type MovimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Movimientos.
     */
    data: MovimientoCreateManyInput | MovimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Movimiento createManyAndReturn
   */
  export type MovimientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Movimientos.
     */
    data: MovimientoCreateManyInput | MovimientoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Movimiento update
   */
  export type MovimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Movimiento.
     */
    data: XOR<MovimientoUpdateInput, MovimientoUncheckedUpdateInput>
    /**
     * Choose, which Movimiento to update.
     */
    where: MovimientoWhereUniqueInput
  }

  /**
   * Movimiento updateMany
   */
  export type MovimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Movimientos.
     */
    data: XOR<MovimientoUpdateManyMutationInput, MovimientoUncheckedUpdateManyInput>
    /**
     * Filter which Movimientos to update
     */
    where?: MovimientoWhereInput
  }

  /**
   * Movimiento upsert
   */
  export type MovimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Movimiento to update in case it exists.
     */
    where: MovimientoWhereUniqueInput
    /**
     * In case the Movimiento found by the `where` argument doesn't exist, create a new Movimiento with this data.
     */
    create: XOR<MovimientoCreateInput, MovimientoUncheckedCreateInput>
    /**
     * In case the Movimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MovimientoUpdateInput, MovimientoUncheckedUpdateInput>
  }

  /**
   * Movimiento delete
   */
  export type MovimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    /**
     * Filter which Movimiento to delete.
     */
    where: MovimientoWhereUniqueInput
  }

  /**
   * Movimiento deleteMany
   */
  export type MovimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Movimientos to delete
     */
    where?: MovimientoWhereInput
  }

  /**
   * Movimiento without action
   */
  export type MovimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
  }


  /**
   * Model CatMov
   */

  export type AggregateCatMov = {
    _count: CatMovCountAggregateOutputType | null
    _min: CatMovMinAggregateOutputType | null
    _max: CatMovMaxAggregateOutputType | null
  }

  export type CatMovMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type CatMovMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type CatMovCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type CatMovMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type CatMovMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type CatMovCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type CatMovAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatMov to aggregate.
     */
    where?: CatMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatMovs to fetch.
     */
    orderBy?: CatMovOrderByWithRelationInput | CatMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatMovs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatMovs
    **/
    _count?: true | CatMovCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatMovMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatMovMaxAggregateInputType
  }

  export type GetCatMovAggregateType<T extends CatMovAggregateArgs> = {
        [P in keyof T & keyof AggregateCatMov]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatMov[P]>
      : GetScalarType<T[P], AggregateCatMov[P]>
  }




  export type CatMovGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatMovWhereInput
    orderBy?: CatMovOrderByWithAggregationInput | CatMovOrderByWithAggregationInput[]
    by: CatMovScalarFieldEnum[] | CatMovScalarFieldEnum
    having?: CatMovScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatMovCountAggregateInputType | true
    _min?: CatMovMinAggregateInputType
    _max?: CatMovMaxAggregateInputType
  }

  export type CatMovGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    _count: CatMovCountAggregateOutputType | null
    _min: CatMovMinAggregateOutputType | null
    _max: CatMovMaxAggregateOutputType | null
  }

  type GetCatMovGroupByPayload<T extends CatMovGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatMovGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatMovGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatMovGroupByOutputType[P]>
            : GetScalarType<T[P], CatMovGroupByOutputType[P]>
        }
      >
    >


  export type CatMovSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    movimientos?: boolean | CatMov$movimientosArgs<ExtArgs>
    subcategorias?: boolean | CatMov$subcategoriasArgs<ExtArgs>
    _count?: boolean | CatMovCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catMov"]>

  export type CatMovSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["catMov"]>

  export type CatMovSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type CatMovInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    movimientos?: boolean | CatMov$movimientosArgs<ExtArgs>
    subcategorias?: boolean | CatMov$subcategoriasArgs<ExtArgs>
    _count?: boolean | CatMovCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatMovIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CatMovPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatMov"
    objects: {
      movimientos: Prisma.$MovimientoPayload<ExtArgs>[]
      subcategorias: Prisma.$SubcatMovimientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["catMov"]>
    composites: {}
  }

  type CatMovGetPayload<S extends boolean | null | undefined | CatMovDefaultArgs> = $Result.GetResult<Prisma.$CatMovPayload, S>

  type CatMovCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatMovFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatMovCountAggregateInputType | true
    }

  export interface CatMovDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatMov'], meta: { name: 'CatMov' } }
    /**
     * Find zero or one CatMov that matches the filter.
     * @param {CatMovFindUniqueArgs} args - Arguments to find a CatMov
     * @example
     * // Get one CatMov
     * const catMov = await prisma.catMov.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatMovFindUniqueArgs>(args: SelectSubset<T, CatMovFindUniqueArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatMov that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatMovFindUniqueOrThrowArgs} args - Arguments to find a CatMov
     * @example
     * // Get one CatMov
     * const catMov = await prisma.catMov.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatMovFindUniqueOrThrowArgs>(args: SelectSubset<T, CatMovFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatMov that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatMovFindFirstArgs} args - Arguments to find a CatMov
     * @example
     * // Get one CatMov
     * const catMov = await prisma.catMov.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatMovFindFirstArgs>(args?: SelectSubset<T, CatMovFindFirstArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatMov that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatMovFindFirstOrThrowArgs} args - Arguments to find a CatMov
     * @example
     * // Get one CatMov
     * const catMov = await prisma.catMov.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatMovFindFirstOrThrowArgs>(args?: SelectSubset<T, CatMovFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatMovs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatMovFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatMovs
     * const catMovs = await prisma.catMov.findMany()
     * 
     * // Get first 10 CatMovs
     * const catMovs = await prisma.catMov.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catMovWithIdOnly = await prisma.catMov.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatMovFindManyArgs>(args?: SelectSubset<T, CatMovFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatMov.
     * @param {CatMovCreateArgs} args - Arguments to create a CatMov.
     * @example
     * // Create one CatMov
     * const CatMov = await prisma.catMov.create({
     *   data: {
     *     // ... data to create a CatMov
     *   }
     * })
     * 
     */
    create<T extends CatMovCreateArgs>(args: SelectSubset<T, CatMovCreateArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatMovs.
     * @param {CatMovCreateManyArgs} args - Arguments to create many CatMovs.
     * @example
     * // Create many CatMovs
     * const catMov = await prisma.catMov.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatMovCreateManyArgs>(args?: SelectSubset<T, CatMovCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatMovs and returns the data saved in the database.
     * @param {CatMovCreateManyAndReturnArgs} args - Arguments to create many CatMovs.
     * @example
     * // Create many CatMovs
     * const catMov = await prisma.catMov.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatMovs and only return the `id`
     * const catMovWithIdOnly = await prisma.catMov.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatMovCreateManyAndReturnArgs>(args?: SelectSubset<T, CatMovCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatMov.
     * @param {CatMovDeleteArgs} args - Arguments to delete one CatMov.
     * @example
     * // Delete one CatMov
     * const CatMov = await prisma.catMov.delete({
     *   where: {
     *     // ... filter to delete one CatMov
     *   }
     * })
     * 
     */
    delete<T extends CatMovDeleteArgs>(args: SelectSubset<T, CatMovDeleteArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatMov.
     * @param {CatMovUpdateArgs} args - Arguments to update one CatMov.
     * @example
     * // Update one CatMov
     * const catMov = await prisma.catMov.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatMovUpdateArgs>(args: SelectSubset<T, CatMovUpdateArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatMovs.
     * @param {CatMovDeleteManyArgs} args - Arguments to filter CatMovs to delete.
     * @example
     * // Delete a few CatMovs
     * const { count } = await prisma.catMov.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatMovDeleteManyArgs>(args?: SelectSubset<T, CatMovDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatMovs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatMovUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatMovs
     * const catMov = await prisma.catMov.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatMovUpdateManyArgs>(args: SelectSubset<T, CatMovUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatMov.
     * @param {CatMovUpsertArgs} args - Arguments to update or create a CatMov.
     * @example
     * // Update or create a CatMov
     * const catMov = await prisma.catMov.upsert({
     *   create: {
     *     // ... data to create a CatMov
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatMov we want to update
     *   }
     * })
     */
    upsert<T extends CatMovUpsertArgs>(args: SelectSubset<T, CatMovUpsertArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatMovs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatMovCountArgs} args - Arguments to filter CatMovs to count.
     * @example
     * // Count the number of CatMovs
     * const count = await prisma.catMov.count({
     *   where: {
     *     // ... the filter for the CatMovs we want to count
     *   }
     * })
    **/
    count<T extends CatMovCountArgs>(
      args?: Subset<T, CatMovCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatMovCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatMov.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatMovAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatMovAggregateArgs>(args: Subset<T, CatMovAggregateArgs>): Prisma.PrismaPromise<GetCatMovAggregateType<T>>

    /**
     * Group by CatMov.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatMovGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatMovGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatMovGroupByArgs['orderBy'] }
        : { orderBy?: CatMovGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatMovGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatMovGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatMov model
   */
  readonly fields: CatMovFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatMov.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatMovClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    movimientos<T extends CatMov$movimientosArgs<ExtArgs> = {}>(args?: Subset<T, CatMov$movimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findMany"> | Null>
    subcategorias<T extends CatMov$subcategoriasArgs<ExtArgs> = {}>(args?: Subset<T, CatMov$subcategoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatMov model
   */ 
  interface CatMovFieldRefs {
    readonly id: FieldRef<"CatMov", 'String'>
    readonly nombre: FieldRef<"CatMov", 'String'>
    readonly descripcion: FieldRef<"CatMov", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CatMov findUnique
   */
  export type CatMovFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * Filter, which CatMov to fetch.
     */
    where: CatMovWhereUniqueInput
  }

  /**
   * CatMov findUniqueOrThrow
   */
  export type CatMovFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * Filter, which CatMov to fetch.
     */
    where: CatMovWhereUniqueInput
  }

  /**
   * CatMov findFirst
   */
  export type CatMovFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * Filter, which CatMov to fetch.
     */
    where?: CatMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatMovs to fetch.
     */
    orderBy?: CatMovOrderByWithRelationInput | CatMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatMovs.
     */
    cursor?: CatMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatMovs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatMovs.
     */
    distinct?: CatMovScalarFieldEnum | CatMovScalarFieldEnum[]
  }

  /**
   * CatMov findFirstOrThrow
   */
  export type CatMovFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * Filter, which CatMov to fetch.
     */
    where?: CatMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatMovs to fetch.
     */
    orderBy?: CatMovOrderByWithRelationInput | CatMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatMovs.
     */
    cursor?: CatMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatMovs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatMovs.
     */
    distinct?: CatMovScalarFieldEnum | CatMovScalarFieldEnum[]
  }

  /**
   * CatMov findMany
   */
  export type CatMovFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * Filter, which CatMovs to fetch.
     */
    where?: CatMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatMovs to fetch.
     */
    orderBy?: CatMovOrderByWithRelationInput | CatMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatMovs.
     */
    cursor?: CatMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatMovs.
     */
    skip?: number
    distinct?: CatMovScalarFieldEnum | CatMovScalarFieldEnum[]
  }

  /**
   * CatMov create
   */
  export type CatMovCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * The data needed to create a CatMov.
     */
    data: XOR<CatMovCreateInput, CatMovUncheckedCreateInput>
  }

  /**
   * CatMov createMany
   */
  export type CatMovCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatMovs.
     */
    data: CatMovCreateManyInput | CatMovCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatMov createManyAndReturn
   */
  export type CatMovCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatMovs.
     */
    data: CatMovCreateManyInput | CatMovCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatMov update
   */
  export type CatMovUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * The data needed to update a CatMov.
     */
    data: XOR<CatMovUpdateInput, CatMovUncheckedUpdateInput>
    /**
     * Choose, which CatMov to update.
     */
    where: CatMovWhereUniqueInput
  }

  /**
   * CatMov updateMany
   */
  export type CatMovUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatMovs.
     */
    data: XOR<CatMovUpdateManyMutationInput, CatMovUncheckedUpdateManyInput>
    /**
     * Filter which CatMovs to update
     */
    where?: CatMovWhereInput
  }

  /**
   * CatMov upsert
   */
  export type CatMovUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * The filter to search for the CatMov to update in case it exists.
     */
    where: CatMovWhereUniqueInput
    /**
     * In case the CatMov found by the `where` argument doesn't exist, create a new CatMov with this data.
     */
    create: XOR<CatMovCreateInput, CatMovUncheckedCreateInput>
    /**
     * In case the CatMov was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatMovUpdateInput, CatMovUncheckedUpdateInput>
  }

  /**
   * CatMov delete
   */
  export type CatMovDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
    /**
     * Filter which CatMov to delete.
     */
    where: CatMovWhereUniqueInput
  }

  /**
   * CatMov deleteMany
   */
  export type CatMovDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatMovs to delete
     */
    where?: CatMovWhereInput
  }

  /**
   * CatMov.movimientos
   */
  export type CatMov$movimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    where?: MovimientoWhereInput
    orderBy?: MovimientoOrderByWithRelationInput | MovimientoOrderByWithRelationInput[]
    cursor?: MovimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovimientoScalarFieldEnum | MovimientoScalarFieldEnum[]
  }

  /**
   * CatMov.subcategorias
   */
  export type CatMov$subcategoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    where?: SubcatMovimientoWhereInput
    orderBy?: SubcatMovimientoOrderByWithRelationInput | SubcatMovimientoOrderByWithRelationInput[]
    cursor?: SubcatMovimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubcatMovimientoScalarFieldEnum | SubcatMovimientoScalarFieldEnum[]
  }

  /**
   * CatMov without action
   */
  export type CatMovDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatMov
     */
    select?: CatMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatMovInclude<ExtArgs> | null
  }


  /**
   * Model SubcatMovimiento
   */

  export type AggregateSubcatMovimiento = {
    _count: SubcatMovimientoCountAggregateOutputType | null
    _min: SubcatMovimientoMinAggregateOutputType | null
    _max: SubcatMovimientoMaxAggregateOutputType | null
  }

  export type SubcatMovimientoMinAggregateOutputType = {
    id: string | null
    catMovId: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type SubcatMovimientoMaxAggregateOutputType = {
    id: string | null
    catMovId: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type SubcatMovimientoCountAggregateOutputType = {
    id: number
    catMovId: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type SubcatMovimientoMinAggregateInputType = {
    id?: true
    catMovId?: true
    nombre?: true
    descripcion?: true
  }

  export type SubcatMovimientoMaxAggregateInputType = {
    id?: true
    catMovId?: true
    nombre?: true
    descripcion?: true
  }

  export type SubcatMovimientoCountAggregateInputType = {
    id?: true
    catMovId?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type SubcatMovimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubcatMovimiento to aggregate.
     */
    where?: SubcatMovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubcatMovimientos to fetch.
     */
    orderBy?: SubcatMovimientoOrderByWithRelationInput | SubcatMovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubcatMovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubcatMovimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubcatMovimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubcatMovimientos
    **/
    _count?: true | SubcatMovimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubcatMovimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubcatMovimientoMaxAggregateInputType
  }

  export type GetSubcatMovimientoAggregateType<T extends SubcatMovimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateSubcatMovimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubcatMovimiento[P]>
      : GetScalarType<T[P], AggregateSubcatMovimiento[P]>
  }




  export type SubcatMovimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcatMovimientoWhereInput
    orderBy?: SubcatMovimientoOrderByWithAggregationInput | SubcatMovimientoOrderByWithAggregationInput[]
    by: SubcatMovimientoScalarFieldEnum[] | SubcatMovimientoScalarFieldEnum
    having?: SubcatMovimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubcatMovimientoCountAggregateInputType | true
    _min?: SubcatMovimientoMinAggregateInputType
    _max?: SubcatMovimientoMaxAggregateInputType
  }

  export type SubcatMovimientoGroupByOutputType = {
    id: string
    catMovId: string
    nombre: string
    descripcion: string | null
    _count: SubcatMovimientoCountAggregateOutputType | null
    _min: SubcatMovimientoMinAggregateOutputType | null
    _max: SubcatMovimientoMaxAggregateOutputType | null
  }

  type GetSubcatMovimientoGroupByPayload<T extends SubcatMovimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubcatMovimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubcatMovimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubcatMovimientoGroupByOutputType[P]>
            : GetScalarType<T[P], SubcatMovimientoGroupByOutputType[P]>
        }
      >
    >


  export type SubcatMovimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catMovId?: boolean
    nombre?: boolean
    descripcion?: boolean
    catMov?: boolean | CatMovDefaultArgs<ExtArgs>
    movimientos?: boolean | SubcatMovimiento$movimientosArgs<ExtArgs>
    detalles?: boolean | SubcatMovimiento$detallesArgs<ExtArgs>
    _count?: boolean | SubcatMovimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcatMovimiento"]>

  export type SubcatMovimientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    catMovId?: boolean
    nombre?: boolean
    descripcion?: boolean
    catMov?: boolean | CatMovDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcatMovimiento"]>

  export type SubcatMovimientoSelectScalar = {
    id?: boolean
    catMovId?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type SubcatMovimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catMov?: boolean | CatMovDefaultArgs<ExtArgs>
    movimientos?: boolean | SubcatMovimiento$movimientosArgs<ExtArgs>
    detalles?: boolean | SubcatMovimiento$detallesArgs<ExtArgs>
    _count?: boolean | SubcatMovimientoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubcatMovimientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    catMov?: boolean | CatMovDefaultArgs<ExtArgs>
  }

  export type $SubcatMovimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubcatMovimiento"
    objects: {
      catMov: Prisma.$CatMovPayload<ExtArgs>
      movimientos: Prisma.$MovimientoPayload<ExtArgs>[]
      detalles: Prisma.$DetMovPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      catMovId: string
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["subcatMovimiento"]>
    composites: {}
  }

  type SubcatMovimientoGetPayload<S extends boolean | null | undefined | SubcatMovimientoDefaultArgs> = $Result.GetResult<Prisma.$SubcatMovimientoPayload, S>

  type SubcatMovimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubcatMovimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubcatMovimientoCountAggregateInputType | true
    }

  export interface SubcatMovimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubcatMovimiento'], meta: { name: 'SubcatMovimiento' } }
    /**
     * Find zero or one SubcatMovimiento that matches the filter.
     * @param {SubcatMovimientoFindUniqueArgs} args - Arguments to find a SubcatMovimiento
     * @example
     * // Get one SubcatMovimiento
     * const subcatMovimiento = await prisma.subcatMovimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubcatMovimientoFindUniqueArgs>(args: SelectSubset<T, SubcatMovimientoFindUniqueArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubcatMovimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubcatMovimientoFindUniqueOrThrowArgs} args - Arguments to find a SubcatMovimiento
     * @example
     * // Get one SubcatMovimiento
     * const subcatMovimiento = await prisma.subcatMovimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubcatMovimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, SubcatMovimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubcatMovimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcatMovimientoFindFirstArgs} args - Arguments to find a SubcatMovimiento
     * @example
     * // Get one SubcatMovimiento
     * const subcatMovimiento = await prisma.subcatMovimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubcatMovimientoFindFirstArgs>(args?: SelectSubset<T, SubcatMovimientoFindFirstArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubcatMovimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcatMovimientoFindFirstOrThrowArgs} args - Arguments to find a SubcatMovimiento
     * @example
     * // Get one SubcatMovimiento
     * const subcatMovimiento = await prisma.subcatMovimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubcatMovimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, SubcatMovimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubcatMovimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcatMovimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubcatMovimientos
     * const subcatMovimientos = await prisma.subcatMovimiento.findMany()
     * 
     * // Get first 10 SubcatMovimientos
     * const subcatMovimientos = await prisma.subcatMovimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subcatMovimientoWithIdOnly = await prisma.subcatMovimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubcatMovimientoFindManyArgs>(args?: SelectSubset<T, SubcatMovimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubcatMovimiento.
     * @param {SubcatMovimientoCreateArgs} args - Arguments to create a SubcatMovimiento.
     * @example
     * // Create one SubcatMovimiento
     * const SubcatMovimiento = await prisma.subcatMovimiento.create({
     *   data: {
     *     // ... data to create a SubcatMovimiento
     *   }
     * })
     * 
     */
    create<T extends SubcatMovimientoCreateArgs>(args: SelectSubset<T, SubcatMovimientoCreateArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubcatMovimientos.
     * @param {SubcatMovimientoCreateManyArgs} args - Arguments to create many SubcatMovimientos.
     * @example
     * // Create many SubcatMovimientos
     * const subcatMovimiento = await prisma.subcatMovimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubcatMovimientoCreateManyArgs>(args?: SelectSubset<T, SubcatMovimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubcatMovimientos and returns the data saved in the database.
     * @param {SubcatMovimientoCreateManyAndReturnArgs} args - Arguments to create many SubcatMovimientos.
     * @example
     * // Create many SubcatMovimientos
     * const subcatMovimiento = await prisma.subcatMovimiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubcatMovimientos and only return the `id`
     * const subcatMovimientoWithIdOnly = await prisma.subcatMovimiento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubcatMovimientoCreateManyAndReturnArgs>(args?: SelectSubset<T, SubcatMovimientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubcatMovimiento.
     * @param {SubcatMovimientoDeleteArgs} args - Arguments to delete one SubcatMovimiento.
     * @example
     * // Delete one SubcatMovimiento
     * const SubcatMovimiento = await prisma.subcatMovimiento.delete({
     *   where: {
     *     // ... filter to delete one SubcatMovimiento
     *   }
     * })
     * 
     */
    delete<T extends SubcatMovimientoDeleteArgs>(args: SelectSubset<T, SubcatMovimientoDeleteArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubcatMovimiento.
     * @param {SubcatMovimientoUpdateArgs} args - Arguments to update one SubcatMovimiento.
     * @example
     * // Update one SubcatMovimiento
     * const subcatMovimiento = await prisma.subcatMovimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubcatMovimientoUpdateArgs>(args: SelectSubset<T, SubcatMovimientoUpdateArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubcatMovimientos.
     * @param {SubcatMovimientoDeleteManyArgs} args - Arguments to filter SubcatMovimientos to delete.
     * @example
     * // Delete a few SubcatMovimientos
     * const { count } = await prisma.subcatMovimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubcatMovimientoDeleteManyArgs>(args?: SelectSubset<T, SubcatMovimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubcatMovimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcatMovimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubcatMovimientos
     * const subcatMovimiento = await prisma.subcatMovimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubcatMovimientoUpdateManyArgs>(args: SelectSubset<T, SubcatMovimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubcatMovimiento.
     * @param {SubcatMovimientoUpsertArgs} args - Arguments to update or create a SubcatMovimiento.
     * @example
     * // Update or create a SubcatMovimiento
     * const subcatMovimiento = await prisma.subcatMovimiento.upsert({
     *   create: {
     *     // ... data to create a SubcatMovimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubcatMovimiento we want to update
     *   }
     * })
     */
    upsert<T extends SubcatMovimientoUpsertArgs>(args: SelectSubset<T, SubcatMovimientoUpsertArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubcatMovimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcatMovimientoCountArgs} args - Arguments to filter SubcatMovimientos to count.
     * @example
     * // Count the number of SubcatMovimientos
     * const count = await prisma.subcatMovimiento.count({
     *   where: {
     *     // ... the filter for the SubcatMovimientos we want to count
     *   }
     * })
    **/
    count<T extends SubcatMovimientoCountArgs>(
      args?: Subset<T, SubcatMovimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubcatMovimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubcatMovimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcatMovimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubcatMovimientoAggregateArgs>(args: Subset<T, SubcatMovimientoAggregateArgs>): Prisma.PrismaPromise<GetSubcatMovimientoAggregateType<T>>

    /**
     * Group by SubcatMovimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcatMovimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubcatMovimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubcatMovimientoGroupByArgs['orderBy'] }
        : { orderBy?: SubcatMovimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubcatMovimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubcatMovimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubcatMovimiento model
   */
  readonly fields: SubcatMovimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubcatMovimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubcatMovimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    catMov<T extends CatMovDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatMovDefaultArgs<ExtArgs>>): Prisma__CatMovClient<$Result.GetResult<Prisma.$CatMovPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movimientos<T extends SubcatMovimiento$movimientosArgs<ExtArgs> = {}>(args?: Subset<T, SubcatMovimiento$movimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findMany"> | Null>
    detalles<T extends SubcatMovimiento$detallesArgs<ExtArgs> = {}>(args?: Subset<T, SubcatMovimiento$detallesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubcatMovimiento model
   */ 
  interface SubcatMovimientoFieldRefs {
    readonly id: FieldRef<"SubcatMovimiento", 'String'>
    readonly catMovId: FieldRef<"SubcatMovimiento", 'String'>
    readonly nombre: FieldRef<"SubcatMovimiento", 'String'>
    readonly descripcion: FieldRef<"SubcatMovimiento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubcatMovimiento findUnique
   */
  export type SubcatMovimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * Filter, which SubcatMovimiento to fetch.
     */
    where: SubcatMovimientoWhereUniqueInput
  }

  /**
   * SubcatMovimiento findUniqueOrThrow
   */
  export type SubcatMovimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * Filter, which SubcatMovimiento to fetch.
     */
    where: SubcatMovimientoWhereUniqueInput
  }

  /**
   * SubcatMovimiento findFirst
   */
  export type SubcatMovimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * Filter, which SubcatMovimiento to fetch.
     */
    where?: SubcatMovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubcatMovimientos to fetch.
     */
    orderBy?: SubcatMovimientoOrderByWithRelationInput | SubcatMovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubcatMovimientos.
     */
    cursor?: SubcatMovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubcatMovimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubcatMovimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubcatMovimientos.
     */
    distinct?: SubcatMovimientoScalarFieldEnum | SubcatMovimientoScalarFieldEnum[]
  }

  /**
   * SubcatMovimiento findFirstOrThrow
   */
  export type SubcatMovimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * Filter, which SubcatMovimiento to fetch.
     */
    where?: SubcatMovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubcatMovimientos to fetch.
     */
    orderBy?: SubcatMovimientoOrderByWithRelationInput | SubcatMovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubcatMovimientos.
     */
    cursor?: SubcatMovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubcatMovimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubcatMovimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubcatMovimientos.
     */
    distinct?: SubcatMovimientoScalarFieldEnum | SubcatMovimientoScalarFieldEnum[]
  }

  /**
   * SubcatMovimiento findMany
   */
  export type SubcatMovimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * Filter, which SubcatMovimientos to fetch.
     */
    where?: SubcatMovimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubcatMovimientos to fetch.
     */
    orderBy?: SubcatMovimientoOrderByWithRelationInput | SubcatMovimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubcatMovimientos.
     */
    cursor?: SubcatMovimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubcatMovimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubcatMovimientos.
     */
    skip?: number
    distinct?: SubcatMovimientoScalarFieldEnum | SubcatMovimientoScalarFieldEnum[]
  }

  /**
   * SubcatMovimiento create
   */
  export type SubcatMovimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a SubcatMovimiento.
     */
    data: XOR<SubcatMovimientoCreateInput, SubcatMovimientoUncheckedCreateInput>
  }

  /**
   * SubcatMovimiento createMany
   */
  export type SubcatMovimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubcatMovimientos.
     */
    data: SubcatMovimientoCreateManyInput | SubcatMovimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubcatMovimiento createManyAndReturn
   */
  export type SubcatMovimientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubcatMovimientos.
     */
    data: SubcatMovimientoCreateManyInput | SubcatMovimientoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubcatMovimiento update
   */
  export type SubcatMovimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a SubcatMovimiento.
     */
    data: XOR<SubcatMovimientoUpdateInput, SubcatMovimientoUncheckedUpdateInput>
    /**
     * Choose, which SubcatMovimiento to update.
     */
    where: SubcatMovimientoWhereUniqueInput
  }

  /**
   * SubcatMovimiento updateMany
   */
  export type SubcatMovimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubcatMovimientos.
     */
    data: XOR<SubcatMovimientoUpdateManyMutationInput, SubcatMovimientoUncheckedUpdateManyInput>
    /**
     * Filter which SubcatMovimientos to update
     */
    where?: SubcatMovimientoWhereInput
  }

  /**
   * SubcatMovimiento upsert
   */
  export type SubcatMovimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the SubcatMovimiento to update in case it exists.
     */
    where: SubcatMovimientoWhereUniqueInput
    /**
     * In case the SubcatMovimiento found by the `where` argument doesn't exist, create a new SubcatMovimiento with this data.
     */
    create: XOR<SubcatMovimientoCreateInput, SubcatMovimientoUncheckedCreateInput>
    /**
     * In case the SubcatMovimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubcatMovimientoUpdateInput, SubcatMovimientoUncheckedUpdateInput>
  }

  /**
   * SubcatMovimiento delete
   */
  export type SubcatMovimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
    /**
     * Filter which SubcatMovimiento to delete.
     */
    where: SubcatMovimientoWhereUniqueInput
  }

  /**
   * SubcatMovimiento deleteMany
   */
  export type SubcatMovimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubcatMovimientos to delete
     */
    where?: SubcatMovimientoWhereInput
  }

  /**
   * SubcatMovimiento.movimientos
   */
  export type SubcatMovimiento$movimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    where?: MovimientoWhereInput
    orderBy?: MovimientoOrderByWithRelationInput | MovimientoOrderByWithRelationInput[]
    cursor?: MovimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovimientoScalarFieldEnum | MovimientoScalarFieldEnum[]
  }

  /**
   * SubcatMovimiento.detalles
   */
  export type SubcatMovimiento$detallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    where?: DetMovWhereInput
    orderBy?: DetMovOrderByWithRelationInput | DetMovOrderByWithRelationInput[]
    cursor?: DetMovWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetMovScalarFieldEnum | DetMovScalarFieldEnum[]
  }

  /**
   * SubcatMovimiento without action
   */
  export type SubcatMovimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcatMovimiento
     */
    select?: SubcatMovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcatMovimientoInclude<ExtArgs> | null
  }


  /**
   * Model DetMov
   */

  export type AggregateDetMov = {
    _count: DetMovCountAggregateOutputType | null
    _min: DetMovMinAggregateOutputType | null
    _max: DetMovMaxAggregateOutputType | null
  }

  export type DetMovMinAggregateOutputType = {
    id: string | null
    subcatMovimientoId: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type DetMovMaxAggregateOutputType = {
    id: string | null
    subcatMovimientoId: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type DetMovCountAggregateOutputType = {
    id: number
    subcatMovimientoId: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type DetMovMinAggregateInputType = {
    id?: true
    subcatMovimientoId?: true
    nombre?: true
    descripcion?: true
  }

  export type DetMovMaxAggregateInputType = {
    id?: true
    subcatMovimientoId?: true
    nombre?: true
    descripcion?: true
  }

  export type DetMovCountAggregateInputType = {
    id?: true
    subcatMovimientoId?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type DetMovAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetMov to aggregate.
     */
    where?: DetMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetMovs to fetch.
     */
    orderBy?: DetMovOrderByWithRelationInput | DetMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetMovs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetMovs
    **/
    _count?: true | DetMovCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetMovMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetMovMaxAggregateInputType
  }

  export type GetDetMovAggregateType<T extends DetMovAggregateArgs> = {
        [P in keyof T & keyof AggregateDetMov]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetMov[P]>
      : GetScalarType<T[P], AggregateDetMov[P]>
  }




  export type DetMovGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetMovWhereInput
    orderBy?: DetMovOrderByWithAggregationInput | DetMovOrderByWithAggregationInput[]
    by: DetMovScalarFieldEnum[] | DetMovScalarFieldEnum
    having?: DetMovScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetMovCountAggregateInputType | true
    _min?: DetMovMinAggregateInputType
    _max?: DetMovMaxAggregateInputType
  }

  export type DetMovGroupByOutputType = {
    id: string
    subcatMovimientoId: string
    nombre: string
    descripcion: string | null
    _count: DetMovCountAggregateOutputType | null
    _min: DetMovMinAggregateOutputType | null
    _max: DetMovMaxAggregateOutputType | null
  }

  type GetDetMovGroupByPayload<T extends DetMovGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetMovGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetMovGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetMovGroupByOutputType[P]>
            : GetScalarType<T[P], DetMovGroupByOutputType[P]>
        }
      >
    >


  export type DetMovSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subcatMovimientoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    subcatMovimiento?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
    movimientos?: boolean | DetMov$movimientosArgs<ExtArgs>
    _count?: boolean | DetMovCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detMov"]>

  export type DetMovSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subcatMovimientoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    subcatMovimiento?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detMov"]>

  export type DetMovSelectScalar = {
    id?: boolean
    subcatMovimientoId?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type DetMovInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcatMovimiento?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
    movimientos?: boolean | DetMov$movimientosArgs<ExtArgs>
    _count?: boolean | DetMovCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DetMovIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subcatMovimiento?: boolean | SubcatMovimientoDefaultArgs<ExtArgs>
  }

  export type $DetMovPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetMov"
    objects: {
      subcatMovimiento: Prisma.$SubcatMovimientoPayload<ExtArgs>
      movimientos: Prisma.$MovimientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subcatMovimientoId: string
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["detMov"]>
    composites: {}
  }

  type DetMovGetPayload<S extends boolean | null | undefined | DetMovDefaultArgs> = $Result.GetResult<Prisma.$DetMovPayload, S>

  type DetMovCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DetMovFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DetMovCountAggregateInputType | true
    }

  export interface DetMovDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetMov'], meta: { name: 'DetMov' } }
    /**
     * Find zero or one DetMov that matches the filter.
     * @param {DetMovFindUniqueArgs} args - Arguments to find a DetMov
     * @example
     * // Get one DetMov
     * const detMov = await prisma.detMov.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetMovFindUniqueArgs>(args: SelectSubset<T, DetMovFindUniqueArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DetMov that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DetMovFindUniqueOrThrowArgs} args - Arguments to find a DetMov
     * @example
     * // Get one DetMov
     * const detMov = await prisma.detMov.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetMovFindUniqueOrThrowArgs>(args: SelectSubset<T, DetMovFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DetMov that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetMovFindFirstArgs} args - Arguments to find a DetMov
     * @example
     * // Get one DetMov
     * const detMov = await prisma.detMov.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetMovFindFirstArgs>(args?: SelectSubset<T, DetMovFindFirstArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DetMov that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetMovFindFirstOrThrowArgs} args - Arguments to find a DetMov
     * @example
     * // Get one DetMov
     * const detMov = await prisma.detMov.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetMovFindFirstOrThrowArgs>(args?: SelectSubset<T, DetMovFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DetMovs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetMovFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetMovs
     * const detMovs = await prisma.detMov.findMany()
     * 
     * // Get first 10 DetMovs
     * const detMovs = await prisma.detMov.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detMovWithIdOnly = await prisma.detMov.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetMovFindManyArgs>(args?: SelectSubset<T, DetMovFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DetMov.
     * @param {DetMovCreateArgs} args - Arguments to create a DetMov.
     * @example
     * // Create one DetMov
     * const DetMov = await prisma.detMov.create({
     *   data: {
     *     // ... data to create a DetMov
     *   }
     * })
     * 
     */
    create<T extends DetMovCreateArgs>(args: SelectSubset<T, DetMovCreateArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DetMovs.
     * @param {DetMovCreateManyArgs} args - Arguments to create many DetMovs.
     * @example
     * // Create many DetMovs
     * const detMov = await prisma.detMov.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetMovCreateManyArgs>(args?: SelectSubset<T, DetMovCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetMovs and returns the data saved in the database.
     * @param {DetMovCreateManyAndReturnArgs} args - Arguments to create many DetMovs.
     * @example
     * // Create many DetMovs
     * const detMov = await prisma.detMov.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetMovs and only return the `id`
     * const detMovWithIdOnly = await prisma.detMov.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetMovCreateManyAndReturnArgs>(args?: SelectSubset<T, DetMovCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DetMov.
     * @param {DetMovDeleteArgs} args - Arguments to delete one DetMov.
     * @example
     * // Delete one DetMov
     * const DetMov = await prisma.detMov.delete({
     *   where: {
     *     // ... filter to delete one DetMov
     *   }
     * })
     * 
     */
    delete<T extends DetMovDeleteArgs>(args: SelectSubset<T, DetMovDeleteArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DetMov.
     * @param {DetMovUpdateArgs} args - Arguments to update one DetMov.
     * @example
     * // Update one DetMov
     * const detMov = await prisma.detMov.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetMovUpdateArgs>(args: SelectSubset<T, DetMovUpdateArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DetMovs.
     * @param {DetMovDeleteManyArgs} args - Arguments to filter DetMovs to delete.
     * @example
     * // Delete a few DetMovs
     * const { count } = await prisma.detMov.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetMovDeleteManyArgs>(args?: SelectSubset<T, DetMovDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetMovs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetMovUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetMovs
     * const detMov = await prisma.detMov.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetMovUpdateManyArgs>(args: SelectSubset<T, DetMovUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetMov.
     * @param {DetMovUpsertArgs} args - Arguments to update or create a DetMov.
     * @example
     * // Update or create a DetMov
     * const detMov = await prisma.detMov.upsert({
     *   create: {
     *     // ... data to create a DetMov
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetMov we want to update
     *   }
     * })
     */
    upsert<T extends DetMovUpsertArgs>(args: SelectSubset<T, DetMovUpsertArgs<ExtArgs>>): Prisma__DetMovClient<$Result.GetResult<Prisma.$DetMovPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DetMovs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetMovCountArgs} args - Arguments to filter DetMovs to count.
     * @example
     * // Count the number of DetMovs
     * const count = await prisma.detMov.count({
     *   where: {
     *     // ... the filter for the DetMovs we want to count
     *   }
     * })
    **/
    count<T extends DetMovCountArgs>(
      args?: Subset<T, DetMovCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetMovCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetMov.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetMovAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetMovAggregateArgs>(args: Subset<T, DetMovAggregateArgs>): Prisma.PrismaPromise<GetDetMovAggregateType<T>>

    /**
     * Group by DetMov.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetMovGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetMovGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetMovGroupByArgs['orderBy'] }
        : { orderBy?: DetMovGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetMovGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetMovGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetMov model
   */
  readonly fields: DetMovFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetMov.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetMovClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subcatMovimiento<T extends SubcatMovimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubcatMovimientoDefaultArgs<ExtArgs>>): Prisma__SubcatMovimientoClient<$Result.GetResult<Prisma.$SubcatMovimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    movimientos<T extends DetMov$movimientosArgs<ExtArgs> = {}>(args?: Subset<T, DetMov$movimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovimientoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetMov model
   */ 
  interface DetMovFieldRefs {
    readonly id: FieldRef<"DetMov", 'String'>
    readonly subcatMovimientoId: FieldRef<"DetMov", 'String'>
    readonly nombre: FieldRef<"DetMov", 'String'>
    readonly descripcion: FieldRef<"DetMov", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DetMov findUnique
   */
  export type DetMovFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * Filter, which DetMov to fetch.
     */
    where: DetMovWhereUniqueInput
  }

  /**
   * DetMov findUniqueOrThrow
   */
  export type DetMovFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * Filter, which DetMov to fetch.
     */
    where: DetMovWhereUniqueInput
  }

  /**
   * DetMov findFirst
   */
  export type DetMovFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * Filter, which DetMov to fetch.
     */
    where?: DetMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetMovs to fetch.
     */
    orderBy?: DetMovOrderByWithRelationInput | DetMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetMovs.
     */
    cursor?: DetMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetMovs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetMovs.
     */
    distinct?: DetMovScalarFieldEnum | DetMovScalarFieldEnum[]
  }

  /**
   * DetMov findFirstOrThrow
   */
  export type DetMovFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * Filter, which DetMov to fetch.
     */
    where?: DetMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetMovs to fetch.
     */
    orderBy?: DetMovOrderByWithRelationInput | DetMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetMovs.
     */
    cursor?: DetMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetMovs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetMovs.
     */
    distinct?: DetMovScalarFieldEnum | DetMovScalarFieldEnum[]
  }

  /**
   * DetMov findMany
   */
  export type DetMovFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * Filter, which DetMovs to fetch.
     */
    where?: DetMovWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetMovs to fetch.
     */
    orderBy?: DetMovOrderByWithRelationInput | DetMovOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetMovs.
     */
    cursor?: DetMovWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetMovs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetMovs.
     */
    skip?: number
    distinct?: DetMovScalarFieldEnum | DetMovScalarFieldEnum[]
  }

  /**
   * DetMov create
   */
  export type DetMovCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * The data needed to create a DetMov.
     */
    data: XOR<DetMovCreateInput, DetMovUncheckedCreateInput>
  }

  /**
   * DetMov createMany
   */
  export type DetMovCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetMovs.
     */
    data: DetMovCreateManyInput | DetMovCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetMov createManyAndReturn
   */
  export type DetMovCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DetMovs.
     */
    data: DetMovCreateManyInput | DetMovCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetMov update
   */
  export type DetMovUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * The data needed to update a DetMov.
     */
    data: XOR<DetMovUpdateInput, DetMovUncheckedUpdateInput>
    /**
     * Choose, which DetMov to update.
     */
    where: DetMovWhereUniqueInput
  }

  /**
   * DetMov updateMany
   */
  export type DetMovUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetMovs.
     */
    data: XOR<DetMovUpdateManyMutationInput, DetMovUncheckedUpdateManyInput>
    /**
     * Filter which DetMovs to update
     */
    where?: DetMovWhereInput
  }

  /**
   * DetMov upsert
   */
  export type DetMovUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * The filter to search for the DetMov to update in case it exists.
     */
    where: DetMovWhereUniqueInput
    /**
     * In case the DetMov found by the `where` argument doesn't exist, create a new DetMov with this data.
     */
    create: XOR<DetMovCreateInput, DetMovUncheckedCreateInput>
    /**
     * In case the DetMov was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetMovUpdateInput, DetMovUncheckedUpdateInput>
  }

  /**
   * DetMov delete
   */
  export type DetMovDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
    /**
     * Filter which DetMov to delete.
     */
    where: DetMovWhereUniqueInput
  }

  /**
   * DetMov deleteMany
   */
  export type DetMovDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetMovs to delete
     */
    where?: DetMovWhereInput
  }

  /**
   * DetMov.movimientos
   */
  export type DetMov$movimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Movimiento
     */
    select?: MovimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MovimientoInclude<ExtArgs> | null
    where?: MovimientoWhereInput
    orderBy?: MovimientoOrderByWithRelationInput | MovimientoOrderByWithRelationInput[]
    cursor?: MovimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MovimientoScalarFieldEnum | MovimientoScalarFieldEnum[]
  }

  /**
   * DetMov without action
   */
  export type DetMovDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetMov
     */
    select?: DetMovSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetMovInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PersonaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    telefono: 'telefono',
    email: 'email',
    cumpleanos: 'cumpleanos',
    eventoCalendarioId: 'eventoCalendarioId',
    clienteId: 'clienteId'
  };

  export type PersonaScalarFieldEnum = (typeof PersonaScalarFieldEnum)[keyof typeof PersonaScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    email: 'email',
    ciudadId: 'ciudadId'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const CiudadScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type CiudadScalarFieldEnum = (typeof CiudadScalarFieldEnum)[keyof typeof CiudadScalarFieldEnum]


  export const EventoScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    numInvitados: 'numInvitados',
    tipoEventoId: 'tipoEventoId',
    clienteId: 'clienteId',
    carpetaId: 'carpetaId',
    estado: 'estado',
    plannerId: 'plannerId'
  };

  export type EventoScalarFieldEnum = (typeof EventoScalarFieldEnum)[keyof typeof EventoScalarFieldEnum]


  export const TipoEventoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type TipoEventoScalarFieldEnum = (typeof TipoEventoScalarFieldEnum)[keyof typeof TipoEventoScalarFieldEnum]


  export const EmpleadaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    dni: 'dni',
    email: 'email',
    telefono: 'telefono'
  };

  export type EmpleadaScalarFieldEnum = (typeof EmpleadaScalarFieldEnum)[keyof typeof EmpleadaScalarFieldEnum]


  export const EmpleadaRolScalarFieldEnum: {
    id: 'id',
    empleadaId: 'empleadaId',
    rol: 'rol'
  };

  export type EmpleadaRolScalarFieldEnum = (typeof EmpleadaRolScalarFieldEnum)[keyof typeof EmpleadaRolScalarFieldEnum]


  export const MovimientoScalarFieldEnum: {
    id: 'id',
    monto: 'monto',
    moneda: 'moneda',
    categoriaId: 'categoriaId',
    subcategoriaId: 'subcategoriaId',
    detalleId: 'detalleId',
    ingreso: 'ingreso',
    fechaProgramado: 'fechaProgramado',
    fechaRecibido: 'fechaRecibido'
  };

  export type MovimientoScalarFieldEnum = (typeof MovimientoScalarFieldEnum)[keyof typeof MovimientoScalarFieldEnum]


  export const CatMovScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type CatMovScalarFieldEnum = (typeof CatMovScalarFieldEnum)[keyof typeof CatMovScalarFieldEnum]


  export const SubcatMovimientoScalarFieldEnum: {
    id: 'id',
    catMovId: 'catMovId',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type SubcatMovimientoScalarFieldEnum = (typeof SubcatMovimientoScalarFieldEnum)[keyof typeof SubcatMovimientoScalarFieldEnum]


  export const DetMovScalarFieldEnum: {
    id: 'id',
    subcatMovimientoId: 'subcatMovimientoId',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type DetMovScalarFieldEnum = (typeof DetMovScalarFieldEnum)[keyof typeof DetMovScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RolEmpleada'
   */
  export type EnumRolEmpleadaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolEmpleada'>
    


  /**
   * Reference to a field of type 'RolEmpleada[]'
   */
  export type ListEnumRolEmpleadaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolEmpleada[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Moneda'
   */
  export type EnumMonedaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Moneda'>
    


  /**
   * Reference to a field of type 'Moneda[]'
   */
  export type ListEnumMonedaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Moneda[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PersonaWhereInput = {
    AND?: PersonaWhereInput | PersonaWhereInput[]
    OR?: PersonaWhereInput[]
    NOT?: PersonaWhereInput | PersonaWhereInput[]
    id?: StringFilter<"Persona"> | string
    nombre?: StringFilter<"Persona"> | string
    apellido?: StringFilter<"Persona"> | string
    telefono?: StringNullableFilter<"Persona"> | string | null
    email?: StringNullableFilter<"Persona"> | string | null
    cumpleanos?: DateTimeNullableFilter<"Persona"> | Date | string | null
    eventoCalendarioId?: StringNullableFilter<"Persona"> | string | null
    clienteId?: StringNullableFilter<"Persona"> | string | null
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
  }

  export type PersonaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    telefono?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cumpleanos?: SortOrderInput | SortOrder
    eventoCalendarioId?: SortOrderInput | SortOrder
    clienteId?: SortOrderInput | SortOrder
    cliente?: ClienteOrderByWithRelationInput
  }

  export type PersonaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonaWhereInput | PersonaWhereInput[]
    OR?: PersonaWhereInput[]
    NOT?: PersonaWhereInput | PersonaWhereInput[]
    nombre?: StringFilter<"Persona"> | string
    apellido?: StringFilter<"Persona"> | string
    telefono?: StringNullableFilter<"Persona"> | string | null
    email?: StringNullableFilter<"Persona"> | string | null
    cumpleanos?: DateTimeNullableFilter<"Persona"> | Date | string | null
    eventoCalendarioId?: StringNullableFilter<"Persona"> | string | null
    clienteId?: StringNullableFilter<"Persona"> | string | null
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
  }, "id">

  export type PersonaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    telefono?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cumpleanos?: SortOrderInput | SortOrder
    eventoCalendarioId?: SortOrderInput | SortOrder
    clienteId?: SortOrderInput | SortOrder
    _count?: PersonaCountOrderByAggregateInput
    _max?: PersonaMaxOrderByAggregateInput
    _min?: PersonaMinOrderByAggregateInput
  }

  export type PersonaScalarWhereWithAggregatesInput = {
    AND?: PersonaScalarWhereWithAggregatesInput | PersonaScalarWhereWithAggregatesInput[]
    OR?: PersonaScalarWhereWithAggregatesInput[]
    NOT?: PersonaScalarWhereWithAggregatesInput | PersonaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Persona"> | string
    nombre?: StringWithAggregatesFilter<"Persona"> | string
    apellido?: StringWithAggregatesFilter<"Persona"> | string
    telefono?: StringNullableWithAggregatesFilter<"Persona"> | string | null
    email?: StringNullableWithAggregatesFilter<"Persona"> | string | null
    cumpleanos?: DateTimeNullableWithAggregatesFilter<"Persona"> | Date | string | null
    eventoCalendarioId?: StringNullableWithAggregatesFilter<"Persona"> | string | null
    clienteId?: StringNullableWithAggregatesFilter<"Persona"> | string | null
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: StringFilter<"Cliente"> | string
    nombre?: StringFilter<"Cliente"> | string
    email?: StringFilter<"Cliente"> | string
    ciudadId?: StringFilter<"Cliente"> | string
    ciudad?: XOR<CiudadRelationFilter, CiudadWhereInput>
    personas?: PersonaListRelationFilter
    eventos?: EventoListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    ciudadId?: SortOrder
    ciudad?: CiudadOrderByWithRelationInput
    personas?: PersonaOrderByRelationAggregateInput
    eventos?: EventoOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    nombre?: StringFilter<"Cliente"> | string
    email?: StringFilter<"Cliente"> | string
    ciudadId?: StringFilter<"Cliente"> | string
    ciudad?: XOR<CiudadRelationFilter, CiudadWhereInput>
    personas?: PersonaListRelationFilter
    eventos?: EventoListRelationFilter
  }, "id">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    ciudadId?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cliente"> | string
    nombre?: StringWithAggregatesFilter<"Cliente"> | string
    email?: StringWithAggregatesFilter<"Cliente"> | string
    ciudadId?: StringWithAggregatesFilter<"Cliente"> | string
  }

  export type CiudadWhereInput = {
    AND?: CiudadWhereInput | CiudadWhereInput[]
    OR?: CiudadWhereInput[]
    NOT?: CiudadWhereInput | CiudadWhereInput[]
    id?: StringFilter<"Ciudad"> | string
    nombre?: StringFilter<"Ciudad"> | string
    clientes?: ClienteListRelationFilter
  }

  export type CiudadOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    clientes?: ClienteOrderByRelationAggregateInput
  }

  export type CiudadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CiudadWhereInput | CiudadWhereInput[]
    OR?: CiudadWhereInput[]
    NOT?: CiudadWhereInput | CiudadWhereInput[]
    nombre?: StringFilter<"Ciudad"> | string
    clientes?: ClienteListRelationFilter
  }, "id">

  export type CiudadOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: CiudadCountOrderByAggregateInput
    _max?: CiudadMaxOrderByAggregateInput
    _min?: CiudadMinOrderByAggregateInput
  }

  export type CiudadScalarWhereWithAggregatesInput = {
    AND?: CiudadScalarWhereWithAggregatesInput | CiudadScalarWhereWithAggregatesInput[]
    OR?: CiudadScalarWhereWithAggregatesInput[]
    NOT?: CiudadScalarWhereWithAggregatesInput | CiudadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ciudad"> | string
    nombre?: StringWithAggregatesFilter<"Ciudad"> | string
  }

  export type EventoWhereInput = {
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    id?: StringFilter<"Evento"> | string
    fecha?: DateTimeFilter<"Evento"> | Date | string
    numInvitados?: IntFilter<"Evento"> | number
    tipoEventoId?: StringFilter<"Evento"> | string
    clienteId?: StringFilter<"Evento"> | string
    carpetaId?: StringNullableFilter<"Evento"> | string | null
    estado?: StringFilter<"Evento"> | string
    plannerId?: StringFilter<"Evento"> | string
    tipoEvento?: XOR<TipoEventoRelationFilter, TipoEventoWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    planner?: XOR<EmpleadaRelationFilter, EmpleadaWhereInput>
  }

  export type EventoOrderByWithRelationInput = {
    id?: SortOrder
    fecha?: SortOrder
    numInvitados?: SortOrder
    tipoEventoId?: SortOrder
    clienteId?: SortOrder
    carpetaId?: SortOrderInput | SortOrder
    estado?: SortOrder
    plannerId?: SortOrder
    tipoEvento?: TipoEventoOrderByWithRelationInput
    cliente?: ClienteOrderByWithRelationInput
    planner?: EmpleadaOrderByWithRelationInput
  }

  export type EventoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    fecha?: DateTimeFilter<"Evento"> | Date | string
    numInvitados?: IntFilter<"Evento"> | number
    tipoEventoId?: StringFilter<"Evento"> | string
    clienteId?: StringFilter<"Evento"> | string
    carpetaId?: StringNullableFilter<"Evento"> | string | null
    estado?: StringFilter<"Evento"> | string
    plannerId?: StringFilter<"Evento"> | string
    tipoEvento?: XOR<TipoEventoRelationFilter, TipoEventoWhereInput>
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    planner?: XOR<EmpleadaRelationFilter, EmpleadaWhereInput>
  }, "id">

  export type EventoOrderByWithAggregationInput = {
    id?: SortOrder
    fecha?: SortOrder
    numInvitados?: SortOrder
    tipoEventoId?: SortOrder
    clienteId?: SortOrder
    carpetaId?: SortOrderInput | SortOrder
    estado?: SortOrder
    plannerId?: SortOrder
    _count?: EventoCountOrderByAggregateInput
    _avg?: EventoAvgOrderByAggregateInput
    _max?: EventoMaxOrderByAggregateInput
    _min?: EventoMinOrderByAggregateInput
    _sum?: EventoSumOrderByAggregateInput
  }

  export type EventoScalarWhereWithAggregatesInput = {
    AND?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    OR?: EventoScalarWhereWithAggregatesInput[]
    NOT?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evento"> | string
    fecha?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
    numInvitados?: IntWithAggregatesFilter<"Evento"> | number
    tipoEventoId?: StringWithAggregatesFilter<"Evento"> | string
    clienteId?: StringWithAggregatesFilter<"Evento"> | string
    carpetaId?: StringNullableWithAggregatesFilter<"Evento"> | string | null
    estado?: StringWithAggregatesFilter<"Evento"> | string
    plannerId?: StringWithAggregatesFilter<"Evento"> | string
  }

  export type TipoEventoWhereInput = {
    AND?: TipoEventoWhereInput | TipoEventoWhereInput[]
    OR?: TipoEventoWhereInput[]
    NOT?: TipoEventoWhereInput | TipoEventoWhereInput[]
    id?: StringFilter<"TipoEvento"> | string
    nombre?: StringFilter<"TipoEvento"> | string
    eventos?: EventoListRelationFilter
  }

  export type TipoEventoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    eventos?: EventoOrderByRelationAggregateInput
  }

  export type TipoEventoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TipoEventoWhereInput | TipoEventoWhereInput[]
    OR?: TipoEventoWhereInput[]
    NOT?: TipoEventoWhereInput | TipoEventoWhereInput[]
    nombre?: StringFilter<"TipoEvento"> | string
    eventos?: EventoListRelationFilter
  }, "id">

  export type TipoEventoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: TipoEventoCountOrderByAggregateInput
    _max?: TipoEventoMaxOrderByAggregateInput
    _min?: TipoEventoMinOrderByAggregateInput
  }

  export type TipoEventoScalarWhereWithAggregatesInput = {
    AND?: TipoEventoScalarWhereWithAggregatesInput | TipoEventoScalarWhereWithAggregatesInput[]
    OR?: TipoEventoScalarWhereWithAggregatesInput[]
    NOT?: TipoEventoScalarWhereWithAggregatesInput | TipoEventoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TipoEvento"> | string
    nombre?: StringWithAggregatesFilter<"TipoEvento"> | string
  }

  export type EmpleadaWhereInput = {
    AND?: EmpleadaWhereInput | EmpleadaWhereInput[]
    OR?: EmpleadaWhereInput[]
    NOT?: EmpleadaWhereInput | EmpleadaWhereInput[]
    id?: StringFilter<"Empleada"> | string
    nombre?: StringFilter<"Empleada"> | string
    apellido?: StringFilter<"Empleada"> | string
    dni?: StringFilter<"Empleada"> | string
    email?: StringFilter<"Empleada"> | string
    telefono?: StringFilter<"Empleada"> | string
    roles?: EmpleadaRolListRelationFilter
    eventos?: EventoListRelationFilter
  }

  export type EmpleadaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    roles?: EmpleadaRolOrderByRelationAggregateInput
    eventos?: EventoOrderByRelationAggregateInput
  }

  export type EmpleadaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmpleadaWhereInput | EmpleadaWhereInput[]
    OR?: EmpleadaWhereInput[]
    NOT?: EmpleadaWhereInput | EmpleadaWhereInput[]
    nombre?: StringFilter<"Empleada"> | string
    apellido?: StringFilter<"Empleada"> | string
    dni?: StringFilter<"Empleada"> | string
    email?: StringFilter<"Empleada"> | string
    telefono?: StringFilter<"Empleada"> | string
    roles?: EmpleadaRolListRelationFilter
    eventos?: EventoListRelationFilter
  }, "id">

  export type EmpleadaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    _count?: EmpleadaCountOrderByAggregateInput
    _max?: EmpleadaMaxOrderByAggregateInput
    _min?: EmpleadaMinOrderByAggregateInput
  }

  export type EmpleadaScalarWhereWithAggregatesInput = {
    AND?: EmpleadaScalarWhereWithAggregatesInput | EmpleadaScalarWhereWithAggregatesInput[]
    OR?: EmpleadaScalarWhereWithAggregatesInput[]
    NOT?: EmpleadaScalarWhereWithAggregatesInput | EmpleadaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Empleada"> | string
    nombre?: StringWithAggregatesFilter<"Empleada"> | string
    apellido?: StringWithAggregatesFilter<"Empleada"> | string
    dni?: StringWithAggregatesFilter<"Empleada"> | string
    email?: StringWithAggregatesFilter<"Empleada"> | string
    telefono?: StringWithAggregatesFilter<"Empleada"> | string
  }

  export type EmpleadaRolWhereInput = {
    AND?: EmpleadaRolWhereInput | EmpleadaRolWhereInput[]
    OR?: EmpleadaRolWhereInput[]
    NOT?: EmpleadaRolWhereInput | EmpleadaRolWhereInput[]
    id?: StringFilter<"EmpleadaRol"> | string
    empleadaId?: StringFilter<"EmpleadaRol"> | string
    rol?: EnumRolEmpleadaFilter<"EmpleadaRol"> | $Enums.RolEmpleada
    empleada?: XOR<EmpleadaRelationFilter, EmpleadaWhereInput>
  }

  export type EmpleadaRolOrderByWithRelationInput = {
    id?: SortOrder
    empleadaId?: SortOrder
    rol?: SortOrder
    empleada?: EmpleadaOrderByWithRelationInput
  }

  export type EmpleadaRolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmpleadaRolWhereInput | EmpleadaRolWhereInput[]
    OR?: EmpleadaRolWhereInput[]
    NOT?: EmpleadaRolWhereInput | EmpleadaRolWhereInput[]
    empleadaId?: StringFilter<"EmpleadaRol"> | string
    rol?: EnumRolEmpleadaFilter<"EmpleadaRol"> | $Enums.RolEmpleada
    empleada?: XOR<EmpleadaRelationFilter, EmpleadaWhereInput>
  }, "id">

  export type EmpleadaRolOrderByWithAggregationInput = {
    id?: SortOrder
    empleadaId?: SortOrder
    rol?: SortOrder
    _count?: EmpleadaRolCountOrderByAggregateInput
    _max?: EmpleadaRolMaxOrderByAggregateInput
    _min?: EmpleadaRolMinOrderByAggregateInput
  }

  export type EmpleadaRolScalarWhereWithAggregatesInput = {
    AND?: EmpleadaRolScalarWhereWithAggregatesInput | EmpleadaRolScalarWhereWithAggregatesInput[]
    OR?: EmpleadaRolScalarWhereWithAggregatesInput[]
    NOT?: EmpleadaRolScalarWhereWithAggregatesInput | EmpleadaRolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmpleadaRol"> | string
    empleadaId?: StringWithAggregatesFilter<"EmpleadaRol"> | string
    rol?: EnumRolEmpleadaWithAggregatesFilter<"EmpleadaRol"> | $Enums.RolEmpleada
  }

  export type MovimientoWhereInput = {
    AND?: MovimientoWhereInput | MovimientoWhereInput[]
    OR?: MovimientoWhereInput[]
    NOT?: MovimientoWhereInput | MovimientoWhereInput[]
    id?: StringFilter<"Movimiento"> | string
    monto?: FloatFilter<"Movimiento"> | number
    moneda?: EnumMonedaFilter<"Movimiento"> | $Enums.Moneda
    categoriaId?: StringFilter<"Movimiento"> | string
    subcategoriaId?: StringFilter<"Movimiento"> | string
    detalleId?: StringFilter<"Movimiento"> | string
    ingreso?: BoolFilter<"Movimiento"> | boolean
    fechaProgramado?: DateTimeFilter<"Movimiento"> | Date | string
    fechaRecibido?: DateTimeNullableFilter<"Movimiento"> | Date | string | null
    categoria?: XOR<CatMovRelationFilter, CatMovWhereInput>
    subcategoria?: XOR<SubcatMovimientoRelationFilter, SubcatMovimientoWhereInput>
    detalle?: XOR<DetMovRelationFilter, DetMovWhereInput>
  }

  export type MovimientoOrderByWithRelationInput = {
    id?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    categoriaId?: SortOrder
    subcategoriaId?: SortOrder
    detalleId?: SortOrder
    ingreso?: SortOrder
    fechaProgramado?: SortOrder
    fechaRecibido?: SortOrderInput | SortOrder
    categoria?: CatMovOrderByWithRelationInput
    subcategoria?: SubcatMovimientoOrderByWithRelationInput
    detalle?: DetMovOrderByWithRelationInput
  }

  export type MovimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MovimientoWhereInput | MovimientoWhereInput[]
    OR?: MovimientoWhereInput[]
    NOT?: MovimientoWhereInput | MovimientoWhereInput[]
    monto?: FloatFilter<"Movimiento"> | number
    moneda?: EnumMonedaFilter<"Movimiento"> | $Enums.Moneda
    categoriaId?: StringFilter<"Movimiento"> | string
    subcategoriaId?: StringFilter<"Movimiento"> | string
    detalleId?: StringFilter<"Movimiento"> | string
    ingreso?: BoolFilter<"Movimiento"> | boolean
    fechaProgramado?: DateTimeFilter<"Movimiento"> | Date | string
    fechaRecibido?: DateTimeNullableFilter<"Movimiento"> | Date | string | null
    categoria?: XOR<CatMovRelationFilter, CatMovWhereInput>
    subcategoria?: XOR<SubcatMovimientoRelationFilter, SubcatMovimientoWhereInput>
    detalle?: XOR<DetMovRelationFilter, DetMovWhereInput>
  }, "id">

  export type MovimientoOrderByWithAggregationInput = {
    id?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    categoriaId?: SortOrder
    subcategoriaId?: SortOrder
    detalleId?: SortOrder
    ingreso?: SortOrder
    fechaProgramado?: SortOrder
    fechaRecibido?: SortOrderInput | SortOrder
    _count?: MovimientoCountOrderByAggregateInput
    _avg?: MovimientoAvgOrderByAggregateInput
    _max?: MovimientoMaxOrderByAggregateInput
    _min?: MovimientoMinOrderByAggregateInput
    _sum?: MovimientoSumOrderByAggregateInput
  }

  export type MovimientoScalarWhereWithAggregatesInput = {
    AND?: MovimientoScalarWhereWithAggregatesInput | MovimientoScalarWhereWithAggregatesInput[]
    OR?: MovimientoScalarWhereWithAggregatesInput[]
    NOT?: MovimientoScalarWhereWithAggregatesInput | MovimientoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Movimiento"> | string
    monto?: FloatWithAggregatesFilter<"Movimiento"> | number
    moneda?: EnumMonedaWithAggregatesFilter<"Movimiento"> | $Enums.Moneda
    categoriaId?: StringWithAggregatesFilter<"Movimiento"> | string
    subcategoriaId?: StringWithAggregatesFilter<"Movimiento"> | string
    detalleId?: StringWithAggregatesFilter<"Movimiento"> | string
    ingreso?: BoolWithAggregatesFilter<"Movimiento"> | boolean
    fechaProgramado?: DateTimeWithAggregatesFilter<"Movimiento"> | Date | string
    fechaRecibido?: DateTimeNullableWithAggregatesFilter<"Movimiento"> | Date | string | null
  }

  export type CatMovWhereInput = {
    AND?: CatMovWhereInput | CatMovWhereInput[]
    OR?: CatMovWhereInput[]
    NOT?: CatMovWhereInput | CatMovWhereInput[]
    id?: StringFilter<"CatMov"> | string
    nombre?: StringFilter<"CatMov"> | string
    descripcion?: StringNullableFilter<"CatMov"> | string | null
    movimientos?: MovimientoListRelationFilter
    subcategorias?: SubcatMovimientoListRelationFilter
  }

  export type CatMovOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    movimientos?: MovimientoOrderByRelationAggregateInput
    subcategorias?: SubcatMovimientoOrderByRelationAggregateInput
  }

  export type CatMovWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatMovWhereInput | CatMovWhereInput[]
    OR?: CatMovWhereInput[]
    NOT?: CatMovWhereInput | CatMovWhereInput[]
    nombre?: StringFilter<"CatMov"> | string
    descripcion?: StringNullableFilter<"CatMov"> | string | null
    movimientos?: MovimientoListRelationFilter
    subcategorias?: SubcatMovimientoListRelationFilter
  }, "id">

  export type CatMovOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: CatMovCountOrderByAggregateInput
    _max?: CatMovMaxOrderByAggregateInput
    _min?: CatMovMinOrderByAggregateInput
  }

  export type CatMovScalarWhereWithAggregatesInput = {
    AND?: CatMovScalarWhereWithAggregatesInput | CatMovScalarWhereWithAggregatesInput[]
    OR?: CatMovScalarWhereWithAggregatesInput[]
    NOT?: CatMovScalarWhereWithAggregatesInput | CatMovScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatMov"> | string
    nombre?: StringWithAggregatesFilter<"CatMov"> | string
    descripcion?: StringNullableWithAggregatesFilter<"CatMov"> | string | null
  }

  export type SubcatMovimientoWhereInput = {
    AND?: SubcatMovimientoWhereInput | SubcatMovimientoWhereInput[]
    OR?: SubcatMovimientoWhereInput[]
    NOT?: SubcatMovimientoWhereInput | SubcatMovimientoWhereInput[]
    id?: StringFilter<"SubcatMovimiento"> | string
    catMovId?: StringFilter<"SubcatMovimiento"> | string
    nombre?: StringFilter<"SubcatMovimiento"> | string
    descripcion?: StringNullableFilter<"SubcatMovimiento"> | string | null
    catMov?: XOR<CatMovRelationFilter, CatMovWhereInput>
    movimientos?: MovimientoListRelationFilter
    detalles?: DetMovListRelationFilter
  }

  export type SubcatMovimientoOrderByWithRelationInput = {
    id?: SortOrder
    catMovId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    catMov?: CatMovOrderByWithRelationInput
    movimientos?: MovimientoOrderByRelationAggregateInput
    detalles?: DetMovOrderByRelationAggregateInput
  }

  export type SubcatMovimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubcatMovimientoWhereInput | SubcatMovimientoWhereInput[]
    OR?: SubcatMovimientoWhereInput[]
    NOT?: SubcatMovimientoWhereInput | SubcatMovimientoWhereInput[]
    catMovId?: StringFilter<"SubcatMovimiento"> | string
    nombre?: StringFilter<"SubcatMovimiento"> | string
    descripcion?: StringNullableFilter<"SubcatMovimiento"> | string | null
    catMov?: XOR<CatMovRelationFilter, CatMovWhereInput>
    movimientos?: MovimientoListRelationFilter
    detalles?: DetMovListRelationFilter
  }, "id">

  export type SubcatMovimientoOrderByWithAggregationInput = {
    id?: SortOrder
    catMovId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: SubcatMovimientoCountOrderByAggregateInput
    _max?: SubcatMovimientoMaxOrderByAggregateInput
    _min?: SubcatMovimientoMinOrderByAggregateInput
  }

  export type SubcatMovimientoScalarWhereWithAggregatesInput = {
    AND?: SubcatMovimientoScalarWhereWithAggregatesInput | SubcatMovimientoScalarWhereWithAggregatesInput[]
    OR?: SubcatMovimientoScalarWhereWithAggregatesInput[]
    NOT?: SubcatMovimientoScalarWhereWithAggregatesInput | SubcatMovimientoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubcatMovimiento"> | string
    catMovId?: StringWithAggregatesFilter<"SubcatMovimiento"> | string
    nombre?: StringWithAggregatesFilter<"SubcatMovimiento"> | string
    descripcion?: StringNullableWithAggregatesFilter<"SubcatMovimiento"> | string | null
  }

  export type DetMovWhereInput = {
    AND?: DetMovWhereInput | DetMovWhereInput[]
    OR?: DetMovWhereInput[]
    NOT?: DetMovWhereInput | DetMovWhereInput[]
    id?: StringFilter<"DetMov"> | string
    subcatMovimientoId?: StringFilter<"DetMov"> | string
    nombre?: StringFilter<"DetMov"> | string
    descripcion?: StringNullableFilter<"DetMov"> | string | null
    subcatMovimiento?: XOR<SubcatMovimientoRelationFilter, SubcatMovimientoWhereInput>
    movimientos?: MovimientoListRelationFilter
  }

  export type DetMovOrderByWithRelationInput = {
    id?: SortOrder
    subcatMovimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    subcatMovimiento?: SubcatMovimientoOrderByWithRelationInput
    movimientos?: MovimientoOrderByRelationAggregateInput
  }

  export type DetMovWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DetMovWhereInput | DetMovWhereInput[]
    OR?: DetMovWhereInput[]
    NOT?: DetMovWhereInput | DetMovWhereInput[]
    subcatMovimientoId?: StringFilter<"DetMov"> | string
    nombre?: StringFilter<"DetMov"> | string
    descripcion?: StringNullableFilter<"DetMov"> | string | null
    subcatMovimiento?: XOR<SubcatMovimientoRelationFilter, SubcatMovimientoWhereInput>
    movimientos?: MovimientoListRelationFilter
  }, "id">

  export type DetMovOrderByWithAggregationInput = {
    id?: SortOrder
    subcatMovimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: DetMovCountOrderByAggregateInput
    _max?: DetMovMaxOrderByAggregateInput
    _min?: DetMovMinOrderByAggregateInput
  }

  export type DetMovScalarWhereWithAggregatesInput = {
    AND?: DetMovScalarWhereWithAggregatesInput | DetMovScalarWhereWithAggregatesInput[]
    OR?: DetMovScalarWhereWithAggregatesInput[]
    NOT?: DetMovScalarWhereWithAggregatesInput | DetMovScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DetMov"> | string
    subcatMovimientoId?: StringWithAggregatesFilter<"DetMov"> | string
    nombre?: StringWithAggregatesFilter<"DetMov"> | string
    descripcion?: StringNullableWithAggregatesFilter<"DetMov"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonaCreateInput = {
    id?: string
    nombre: string
    apellido: string
    telefono?: string | null
    email?: string | null
    cumpleanos?: Date | string | null
    eventoCalendarioId?: string | null
    cliente?: ClienteCreateNestedOneWithoutPersonasInput
  }

  export type PersonaUncheckedCreateInput = {
    id?: string
    nombre: string
    apellido: string
    telefono?: string | null
    email?: string | null
    cumpleanos?: Date | string | null
    eventoCalendarioId?: string | null
    clienteId?: string | null
  }

  export type PersonaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cumpleanos?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventoCalendarioId?: NullableStringFieldUpdateOperationsInput | string | null
    cliente?: ClienteUpdateOneWithoutPersonasNestedInput
  }

  export type PersonaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cumpleanos?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventoCalendarioId?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaCreateManyInput = {
    id?: string
    nombre: string
    apellido: string
    telefono?: string | null
    email?: string | null
    cumpleanos?: Date | string | null
    eventoCalendarioId?: string | null
    clienteId?: string | null
  }

  export type PersonaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cumpleanos?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventoCalendarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cumpleanos?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventoCalendarioId?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClienteCreateInput = {
    id?: string
    nombre: string
    email: string
    ciudad: CiudadCreateNestedOneWithoutClientesInput
    personas?: PersonaCreateNestedManyWithoutClienteInput
    eventos?: EventoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: string
    nombre: string
    email: string
    ciudadId: string
    personas?: PersonaUncheckedCreateNestedManyWithoutClienteInput
    eventos?: EventoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ciudad?: CiudadUpdateOneRequiredWithoutClientesNestedInput
    personas?: PersonaUpdateManyWithoutClienteNestedInput
    eventos?: EventoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ciudadId?: StringFieldUpdateOperationsInput | string
    personas?: PersonaUncheckedUpdateManyWithoutClienteNestedInput
    eventos?: EventoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: string
    nombre: string
    email: string
    ciudadId: string
  }

  export type ClienteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ciudadId?: StringFieldUpdateOperationsInput | string
  }

  export type CiudadCreateInput = {
    id?: string
    nombre: string
    clientes?: ClienteCreateNestedManyWithoutCiudadInput
  }

  export type CiudadUncheckedCreateInput = {
    id?: string
    nombre: string
    clientes?: ClienteUncheckedCreateNestedManyWithoutCiudadInput
  }

  export type CiudadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    clientes?: ClienteUpdateManyWithoutCiudadNestedInput
  }

  export type CiudadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    clientes?: ClienteUncheckedUpdateManyWithoutCiudadNestedInput
  }

  export type CiudadCreateManyInput = {
    id?: string
    nombre: string
  }

  export type CiudadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CiudadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EventoCreateInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    carpetaId?: string | null
    estado: string
    tipoEvento: TipoEventoCreateNestedOneWithoutEventosInput
    cliente: ClienteCreateNestedOneWithoutEventosInput
    planner: EmpleadaCreateNestedOneWithoutEventosInput
  }

  export type EventoUncheckedCreateInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    tipoEventoId: string
    clienteId: string
    carpetaId?: string | null
    estado: string
    plannerId: string
  }

  export type EventoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    tipoEvento?: TipoEventoUpdateOneRequiredWithoutEventosNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutEventosNestedInput
    planner?: EmpleadaUpdateOneRequiredWithoutEventosNestedInput
  }

  export type EventoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    tipoEventoId?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
  }

  export type EventoCreateManyInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    tipoEventoId: string
    clienteId: string
    carpetaId?: string | null
    estado: string
    plannerId: string
  }

  export type EventoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EventoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    tipoEventoId?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
  }

  export type TipoEventoCreateInput = {
    id?: string
    nombre: string
    eventos?: EventoCreateNestedManyWithoutTipoEventoInput
  }

  export type TipoEventoUncheckedCreateInput = {
    id?: string
    nombre: string
    eventos?: EventoUncheckedCreateNestedManyWithoutTipoEventoInput
  }

  export type TipoEventoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    eventos?: EventoUpdateManyWithoutTipoEventoNestedInput
  }

  export type TipoEventoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    eventos?: EventoUncheckedUpdateManyWithoutTipoEventoNestedInput
  }

  export type TipoEventoCreateManyInput = {
    id?: string
    nombre: string
  }

  export type TipoEventoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TipoEventoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadaCreateInput = {
    id?: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
    roles?: EmpleadaRolCreateNestedManyWithoutEmpleadaInput
    eventos?: EventoCreateNestedManyWithoutPlannerInput
  }

  export type EmpleadaUncheckedCreateInput = {
    id?: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
    roles?: EmpleadaRolUncheckedCreateNestedManyWithoutEmpleadaInput
    eventos?: EventoUncheckedCreateNestedManyWithoutPlannerInput
  }

  export type EmpleadaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    roles?: EmpleadaRolUpdateManyWithoutEmpleadaNestedInput
    eventos?: EventoUpdateManyWithoutPlannerNestedInput
  }

  export type EmpleadaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    roles?: EmpleadaRolUncheckedUpdateManyWithoutEmpleadaNestedInput
    eventos?: EventoUncheckedUpdateManyWithoutPlannerNestedInput
  }

  export type EmpleadaCreateManyInput = {
    id?: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
  }

  export type EmpleadaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadaRolCreateInput = {
    id?: string
    rol: $Enums.RolEmpleada
    empleada: EmpleadaCreateNestedOneWithoutRolesInput
  }

  export type EmpleadaRolUncheckedCreateInput = {
    id?: string
    empleadaId: string
    rol: $Enums.RolEmpleada
  }

  export type EmpleadaRolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolEmpleadaFieldUpdateOperationsInput | $Enums.RolEmpleada
    empleada?: EmpleadaUpdateOneRequiredWithoutRolesNestedInput
  }

  export type EmpleadaRolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    empleadaId?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolEmpleadaFieldUpdateOperationsInput | $Enums.RolEmpleada
  }

  export type EmpleadaRolCreateManyInput = {
    id?: string
    empleadaId: string
    rol: $Enums.RolEmpleada
  }

  export type EmpleadaRolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolEmpleadaFieldUpdateOperationsInput | $Enums.RolEmpleada
  }

  export type EmpleadaRolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    empleadaId?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolEmpleadaFieldUpdateOperationsInput | $Enums.RolEmpleada
  }

  export type MovimientoCreateInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
    categoria: CatMovCreateNestedOneWithoutMovimientosInput
    subcategoria: SubcatMovimientoCreateNestedOneWithoutMovimientosInput
    detalle: DetMovCreateNestedOneWithoutMovimientosInput
  }

  export type MovimientoUncheckedCreateInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    categoriaId: string
    subcategoriaId: string
    detalleId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type MovimientoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoria?: CatMovUpdateOneRequiredWithoutMovimientosNestedInput
    subcategoria?: SubcatMovimientoUpdateOneRequiredWithoutMovimientosNestedInput
    detalle?: DetMovUpdateOneRequiredWithoutMovimientosNestedInput
  }

  export type MovimientoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    categoriaId?: StringFieldUpdateOperationsInput | string
    subcategoriaId?: StringFieldUpdateOperationsInput | string
    detalleId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MovimientoCreateManyInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    categoriaId: string
    subcategoriaId: string
    detalleId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type MovimientoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MovimientoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    categoriaId?: StringFieldUpdateOperationsInput | string
    subcategoriaId?: StringFieldUpdateOperationsInput | string
    detalleId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CatMovCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoCreateNestedManyWithoutCategoriaInput
    subcategorias?: SubcatMovimientoCreateNestedManyWithoutCatMovInput
  }

  export type CatMovUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoUncheckedCreateNestedManyWithoutCategoriaInput
    subcategorias?: SubcatMovimientoUncheckedCreateNestedManyWithoutCatMovInput
  }

  export type CatMovUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUpdateManyWithoutCategoriaNestedInput
    subcategorias?: SubcatMovimientoUpdateManyWithoutCatMovNestedInput
  }

  export type CatMovUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUncheckedUpdateManyWithoutCategoriaNestedInput
    subcategorias?: SubcatMovimientoUncheckedUpdateManyWithoutCatMovNestedInput
  }

  export type CatMovCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
  }

  export type CatMovUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CatMovUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubcatMovimientoCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    catMov: CatMovCreateNestedOneWithoutSubcategoriasInput
    movimientos?: MovimientoCreateNestedManyWithoutSubcategoriaInput
    detalles?: DetMovCreateNestedManyWithoutSubcatMovimientoInput
  }

  export type SubcatMovimientoUncheckedCreateInput = {
    id?: string
    catMovId: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoUncheckedCreateNestedManyWithoutSubcategoriaInput
    detalles?: DetMovUncheckedCreateNestedManyWithoutSubcatMovimientoInput
  }

  export type SubcatMovimientoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    catMov?: CatMovUpdateOneRequiredWithoutSubcategoriasNestedInput
    movimientos?: MovimientoUpdateManyWithoutSubcategoriaNestedInput
    detalles?: DetMovUpdateManyWithoutSubcatMovimientoNestedInput
  }

  export type SubcatMovimientoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    catMovId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUncheckedUpdateManyWithoutSubcategoriaNestedInput
    detalles?: DetMovUncheckedUpdateManyWithoutSubcatMovimientoNestedInput
  }

  export type SubcatMovimientoCreateManyInput = {
    id?: string
    catMovId: string
    nombre: string
    descripcion?: string | null
  }

  export type SubcatMovimientoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubcatMovimientoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    catMovId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DetMovCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    subcatMovimiento: SubcatMovimientoCreateNestedOneWithoutDetallesInput
    movimientos?: MovimientoCreateNestedManyWithoutDetalleInput
  }

  export type DetMovUncheckedCreateInput = {
    id?: string
    subcatMovimientoId: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoUncheckedCreateNestedManyWithoutDetalleInput
  }

  export type DetMovUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    subcatMovimiento?: SubcatMovimientoUpdateOneRequiredWithoutDetallesNestedInput
    movimientos?: MovimientoUpdateManyWithoutDetalleNestedInput
  }

  export type DetMovUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subcatMovimientoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUncheckedUpdateManyWithoutDetalleNestedInput
  }

  export type DetMovCreateManyInput = {
    id?: string
    subcatMovimientoId: string
    nombre: string
    descripcion?: string | null
  }

  export type DetMovUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DetMovUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subcatMovimientoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClienteNullableRelationFilter = {
    is?: ClienteWhereInput | null
    isNot?: ClienteWhereInput | null
  }

  export type PersonaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    telefono?: SortOrder
    email?: SortOrder
    cumpleanos?: SortOrder
    eventoCalendarioId?: SortOrder
    clienteId?: SortOrder
  }

  export type PersonaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    telefono?: SortOrder
    email?: SortOrder
    cumpleanos?: SortOrder
    eventoCalendarioId?: SortOrder
    clienteId?: SortOrder
  }

  export type PersonaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    telefono?: SortOrder
    email?: SortOrder
    cumpleanos?: SortOrder
    eventoCalendarioId?: SortOrder
    clienteId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CiudadRelationFilter = {
    is?: CiudadWhereInput
    isNot?: CiudadWhereInput
  }

  export type PersonaListRelationFilter = {
    every?: PersonaWhereInput
    some?: PersonaWhereInput
    none?: PersonaWhereInput
  }

  export type EventoListRelationFilter = {
    every?: EventoWhereInput
    some?: EventoWhereInput
    none?: EventoWhereInput
  }

  export type PersonaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    ciudadId?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    ciudadId?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    email?: SortOrder
    ciudadId?: SortOrder
  }

  export type ClienteListRelationFilter = {
    every?: ClienteWhereInput
    some?: ClienteWhereInput
    none?: ClienteWhereInput
  }

  export type ClienteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CiudadCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CiudadMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type CiudadMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type TipoEventoRelationFilter = {
    is?: TipoEventoWhereInput
    isNot?: TipoEventoWhereInput
  }

  export type ClienteRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type EmpleadaRelationFilter = {
    is?: EmpleadaWhereInput
    isNot?: EmpleadaWhereInput
  }

  export type EventoCountOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    numInvitados?: SortOrder
    tipoEventoId?: SortOrder
    clienteId?: SortOrder
    carpetaId?: SortOrder
    estado?: SortOrder
    plannerId?: SortOrder
  }

  export type EventoAvgOrderByAggregateInput = {
    numInvitados?: SortOrder
  }

  export type EventoMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    numInvitados?: SortOrder
    tipoEventoId?: SortOrder
    clienteId?: SortOrder
    carpetaId?: SortOrder
    estado?: SortOrder
    plannerId?: SortOrder
  }

  export type EventoMinOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    numInvitados?: SortOrder
    tipoEventoId?: SortOrder
    clienteId?: SortOrder
    carpetaId?: SortOrder
    estado?: SortOrder
    plannerId?: SortOrder
  }

  export type EventoSumOrderByAggregateInput = {
    numInvitados?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type TipoEventoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type TipoEventoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type TipoEventoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type EmpleadaRolListRelationFilter = {
    every?: EmpleadaRolWhereInput
    some?: EmpleadaRolWhereInput
    none?: EmpleadaRolWhereInput
  }

  export type EmpleadaRolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmpleadaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
  }

  export type EmpleadaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
  }

  export type EmpleadaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    dni?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
  }

  export type EnumRolEmpleadaFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEmpleada | EnumRolEmpleadaFieldRefInput<$PrismaModel>
    in?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEmpleadaFilter<$PrismaModel> | $Enums.RolEmpleada
  }

  export type EmpleadaRolCountOrderByAggregateInput = {
    id?: SortOrder
    empleadaId?: SortOrder
    rol?: SortOrder
  }

  export type EmpleadaRolMaxOrderByAggregateInput = {
    id?: SortOrder
    empleadaId?: SortOrder
    rol?: SortOrder
  }

  export type EmpleadaRolMinOrderByAggregateInput = {
    id?: SortOrder
    empleadaId?: SortOrder
    rol?: SortOrder
  }

  export type EnumRolEmpleadaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEmpleada | EnumRolEmpleadaFieldRefInput<$PrismaModel>
    in?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEmpleadaWithAggregatesFilter<$PrismaModel> | $Enums.RolEmpleada
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolEmpleadaFilter<$PrismaModel>
    _max?: NestedEnumRolEmpleadaFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumMonedaFilter<$PrismaModel = never> = {
    equals?: $Enums.Moneda | EnumMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumMonedaFilter<$PrismaModel> | $Enums.Moneda
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CatMovRelationFilter = {
    is?: CatMovWhereInput
    isNot?: CatMovWhereInput
  }

  export type SubcatMovimientoRelationFilter = {
    is?: SubcatMovimientoWhereInput
    isNot?: SubcatMovimientoWhereInput
  }

  export type DetMovRelationFilter = {
    is?: DetMovWhereInput
    isNot?: DetMovWhereInput
  }

  export type MovimientoCountOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    categoriaId?: SortOrder
    subcategoriaId?: SortOrder
    detalleId?: SortOrder
    ingreso?: SortOrder
    fechaProgramado?: SortOrder
    fechaRecibido?: SortOrder
  }

  export type MovimientoAvgOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type MovimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    categoriaId?: SortOrder
    subcategoriaId?: SortOrder
    detalleId?: SortOrder
    ingreso?: SortOrder
    fechaProgramado?: SortOrder
    fechaRecibido?: SortOrder
  }

  export type MovimientoMinOrderByAggregateInput = {
    id?: SortOrder
    monto?: SortOrder
    moneda?: SortOrder
    categoriaId?: SortOrder
    subcategoriaId?: SortOrder
    detalleId?: SortOrder
    ingreso?: SortOrder
    fechaProgramado?: SortOrder
    fechaRecibido?: SortOrder
  }

  export type MovimientoSumOrderByAggregateInput = {
    monto?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumMonedaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Moneda | EnumMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumMonedaWithAggregatesFilter<$PrismaModel> | $Enums.Moneda
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMonedaFilter<$PrismaModel>
    _max?: NestedEnumMonedaFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MovimientoListRelationFilter = {
    every?: MovimientoWhereInput
    some?: MovimientoWhereInput
    none?: MovimientoWhereInput
  }

  export type SubcatMovimientoListRelationFilter = {
    every?: SubcatMovimientoWhereInput
    some?: SubcatMovimientoWhereInput
    none?: SubcatMovimientoWhereInput
  }

  export type MovimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubcatMovimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatMovCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CatMovMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CatMovMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type DetMovListRelationFilter = {
    every?: DetMovWhereInput
    some?: DetMovWhereInput
    none?: DetMovWhereInput
  }

  export type DetMovOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubcatMovimientoCountOrderByAggregateInput = {
    id?: SortOrder
    catMovId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type SubcatMovimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    catMovId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type SubcatMovimientoMinOrderByAggregateInput = {
    id?: SortOrder
    catMovId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type DetMovCountOrderByAggregateInput = {
    id?: SortOrder
    subcatMovimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type DetMovMaxOrderByAggregateInput = {
    id?: SortOrder
    subcatMovimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type DetMovMinOrderByAggregateInput = {
    id?: SortOrder
    subcatMovimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClienteCreateNestedOneWithoutPersonasInput = {
    create?: XOR<ClienteCreateWithoutPersonasInput, ClienteUncheckedCreateWithoutPersonasInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPersonasInput
    connect?: ClienteWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClienteUpdateOneWithoutPersonasNestedInput = {
    create?: XOR<ClienteCreateWithoutPersonasInput, ClienteUncheckedCreateWithoutPersonasInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutPersonasInput
    upsert?: ClienteUpsertWithoutPersonasInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutPersonasInput, ClienteUpdateWithoutPersonasInput>, ClienteUncheckedUpdateWithoutPersonasInput>
  }

  export type CiudadCreateNestedOneWithoutClientesInput = {
    create?: XOR<CiudadCreateWithoutClientesInput, CiudadUncheckedCreateWithoutClientesInput>
    connectOrCreate?: CiudadCreateOrConnectWithoutClientesInput
    connect?: CiudadWhereUniqueInput
  }

  export type PersonaCreateNestedManyWithoutClienteInput = {
    create?: XOR<PersonaCreateWithoutClienteInput, PersonaUncheckedCreateWithoutClienteInput> | PersonaCreateWithoutClienteInput[] | PersonaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutClienteInput | PersonaCreateOrConnectWithoutClienteInput[]
    createMany?: PersonaCreateManyClienteInputEnvelope
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
  }

  export type EventoCreateNestedManyWithoutClienteInput = {
    create?: XOR<EventoCreateWithoutClienteInput, EventoUncheckedCreateWithoutClienteInput> | EventoCreateWithoutClienteInput[] | EventoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClienteInput | EventoCreateOrConnectWithoutClienteInput[]
    createMany?: EventoCreateManyClienteInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type PersonaUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<PersonaCreateWithoutClienteInput, PersonaUncheckedCreateWithoutClienteInput> | PersonaCreateWithoutClienteInput[] | PersonaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutClienteInput | PersonaCreateOrConnectWithoutClienteInput[]
    createMany?: PersonaCreateManyClienteInputEnvelope
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
  }

  export type EventoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<EventoCreateWithoutClienteInput, EventoUncheckedCreateWithoutClienteInput> | EventoCreateWithoutClienteInput[] | EventoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClienteInput | EventoCreateOrConnectWithoutClienteInput[]
    createMany?: EventoCreateManyClienteInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type CiudadUpdateOneRequiredWithoutClientesNestedInput = {
    create?: XOR<CiudadCreateWithoutClientesInput, CiudadUncheckedCreateWithoutClientesInput>
    connectOrCreate?: CiudadCreateOrConnectWithoutClientesInput
    upsert?: CiudadUpsertWithoutClientesInput
    connect?: CiudadWhereUniqueInput
    update?: XOR<XOR<CiudadUpdateToOneWithWhereWithoutClientesInput, CiudadUpdateWithoutClientesInput>, CiudadUncheckedUpdateWithoutClientesInput>
  }

  export type PersonaUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PersonaCreateWithoutClienteInput, PersonaUncheckedCreateWithoutClienteInput> | PersonaCreateWithoutClienteInput[] | PersonaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutClienteInput | PersonaCreateOrConnectWithoutClienteInput[]
    upsert?: PersonaUpsertWithWhereUniqueWithoutClienteInput | PersonaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PersonaCreateManyClienteInputEnvelope
    set?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    disconnect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    delete?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    update?: PersonaUpdateWithWhereUniqueWithoutClienteInput | PersonaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PersonaUpdateManyWithWhereWithoutClienteInput | PersonaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
  }

  export type EventoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<EventoCreateWithoutClienteInput, EventoUncheckedCreateWithoutClienteInput> | EventoCreateWithoutClienteInput[] | EventoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClienteInput | EventoCreateOrConnectWithoutClienteInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutClienteInput | EventoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: EventoCreateManyClienteInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutClienteInput | EventoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutClienteInput | EventoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type PersonaUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<PersonaCreateWithoutClienteInput, PersonaUncheckedCreateWithoutClienteInput> | PersonaCreateWithoutClienteInput[] | PersonaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutClienteInput | PersonaCreateOrConnectWithoutClienteInput[]
    upsert?: PersonaUpsertWithWhereUniqueWithoutClienteInput | PersonaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: PersonaCreateManyClienteInputEnvelope
    set?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    disconnect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    delete?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    update?: PersonaUpdateWithWhereUniqueWithoutClienteInput | PersonaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: PersonaUpdateManyWithWhereWithoutClienteInput | PersonaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
  }

  export type EventoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<EventoCreateWithoutClienteInput, EventoUncheckedCreateWithoutClienteInput> | EventoCreateWithoutClienteInput[] | EventoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutClienteInput | EventoCreateOrConnectWithoutClienteInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutClienteInput | EventoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: EventoCreateManyClienteInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutClienteInput | EventoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutClienteInput | EventoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type ClienteCreateNestedManyWithoutCiudadInput = {
    create?: XOR<ClienteCreateWithoutCiudadInput, ClienteUncheckedCreateWithoutCiudadInput> | ClienteCreateWithoutCiudadInput[] | ClienteUncheckedCreateWithoutCiudadInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutCiudadInput | ClienteCreateOrConnectWithoutCiudadInput[]
    createMany?: ClienteCreateManyCiudadInputEnvelope
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
  }

  export type ClienteUncheckedCreateNestedManyWithoutCiudadInput = {
    create?: XOR<ClienteCreateWithoutCiudadInput, ClienteUncheckedCreateWithoutCiudadInput> | ClienteCreateWithoutCiudadInput[] | ClienteUncheckedCreateWithoutCiudadInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutCiudadInput | ClienteCreateOrConnectWithoutCiudadInput[]
    createMany?: ClienteCreateManyCiudadInputEnvelope
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
  }

  export type ClienteUpdateManyWithoutCiudadNestedInput = {
    create?: XOR<ClienteCreateWithoutCiudadInput, ClienteUncheckedCreateWithoutCiudadInput> | ClienteCreateWithoutCiudadInput[] | ClienteUncheckedCreateWithoutCiudadInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutCiudadInput | ClienteCreateOrConnectWithoutCiudadInput[]
    upsert?: ClienteUpsertWithWhereUniqueWithoutCiudadInput | ClienteUpsertWithWhereUniqueWithoutCiudadInput[]
    createMany?: ClienteCreateManyCiudadInputEnvelope
    set?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    disconnect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    delete?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    update?: ClienteUpdateWithWhereUniqueWithoutCiudadInput | ClienteUpdateWithWhereUniqueWithoutCiudadInput[]
    updateMany?: ClienteUpdateManyWithWhereWithoutCiudadInput | ClienteUpdateManyWithWhereWithoutCiudadInput[]
    deleteMany?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
  }

  export type ClienteUncheckedUpdateManyWithoutCiudadNestedInput = {
    create?: XOR<ClienteCreateWithoutCiudadInput, ClienteUncheckedCreateWithoutCiudadInput> | ClienteCreateWithoutCiudadInput[] | ClienteUncheckedCreateWithoutCiudadInput[]
    connectOrCreate?: ClienteCreateOrConnectWithoutCiudadInput | ClienteCreateOrConnectWithoutCiudadInput[]
    upsert?: ClienteUpsertWithWhereUniqueWithoutCiudadInput | ClienteUpsertWithWhereUniqueWithoutCiudadInput[]
    createMany?: ClienteCreateManyCiudadInputEnvelope
    set?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    disconnect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    delete?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    connect?: ClienteWhereUniqueInput | ClienteWhereUniqueInput[]
    update?: ClienteUpdateWithWhereUniqueWithoutCiudadInput | ClienteUpdateWithWhereUniqueWithoutCiudadInput[]
    updateMany?: ClienteUpdateManyWithWhereWithoutCiudadInput | ClienteUpdateManyWithWhereWithoutCiudadInput[]
    deleteMany?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
  }

  export type TipoEventoCreateNestedOneWithoutEventosInput = {
    create?: XOR<TipoEventoCreateWithoutEventosInput, TipoEventoUncheckedCreateWithoutEventosInput>
    connectOrCreate?: TipoEventoCreateOrConnectWithoutEventosInput
    connect?: TipoEventoWhereUniqueInput
  }

  export type ClienteCreateNestedOneWithoutEventosInput = {
    create?: XOR<ClienteCreateWithoutEventosInput, ClienteUncheckedCreateWithoutEventosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutEventosInput
    connect?: ClienteWhereUniqueInput
  }

  export type EmpleadaCreateNestedOneWithoutEventosInput = {
    create?: XOR<EmpleadaCreateWithoutEventosInput, EmpleadaUncheckedCreateWithoutEventosInput>
    connectOrCreate?: EmpleadaCreateOrConnectWithoutEventosInput
    connect?: EmpleadaWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TipoEventoUpdateOneRequiredWithoutEventosNestedInput = {
    create?: XOR<TipoEventoCreateWithoutEventosInput, TipoEventoUncheckedCreateWithoutEventosInput>
    connectOrCreate?: TipoEventoCreateOrConnectWithoutEventosInput
    upsert?: TipoEventoUpsertWithoutEventosInput
    connect?: TipoEventoWhereUniqueInput
    update?: XOR<XOR<TipoEventoUpdateToOneWithWhereWithoutEventosInput, TipoEventoUpdateWithoutEventosInput>, TipoEventoUncheckedUpdateWithoutEventosInput>
  }

  export type ClienteUpdateOneRequiredWithoutEventosNestedInput = {
    create?: XOR<ClienteCreateWithoutEventosInput, ClienteUncheckedCreateWithoutEventosInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutEventosInput
    upsert?: ClienteUpsertWithoutEventosInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutEventosInput, ClienteUpdateWithoutEventosInput>, ClienteUncheckedUpdateWithoutEventosInput>
  }

  export type EmpleadaUpdateOneRequiredWithoutEventosNestedInput = {
    create?: XOR<EmpleadaCreateWithoutEventosInput, EmpleadaUncheckedCreateWithoutEventosInput>
    connectOrCreate?: EmpleadaCreateOrConnectWithoutEventosInput
    upsert?: EmpleadaUpsertWithoutEventosInput
    connect?: EmpleadaWhereUniqueInput
    update?: XOR<XOR<EmpleadaUpdateToOneWithWhereWithoutEventosInput, EmpleadaUpdateWithoutEventosInput>, EmpleadaUncheckedUpdateWithoutEventosInput>
  }

  export type EventoCreateNestedManyWithoutTipoEventoInput = {
    create?: XOR<EventoCreateWithoutTipoEventoInput, EventoUncheckedCreateWithoutTipoEventoInput> | EventoCreateWithoutTipoEventoInput[] | EventoUncheckedCreateWithoutTipoEventoInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutTipoEventoInput | EventoCreateOrConnectWithoutTipoEventoInput[]
    createMany?: EventoCreateManyTipoEventoInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type EventoUncheckedCreateNestedManyWithoutTipoEventoInput = {
    create?: XOR<EventoCreateWithoutTipoEventoInput, EventoUncheckedCreateWithoutTipoEventoInput> | EventoCreateWithoutTipoEventoInput[] | EventoUncheckedCreateWithoutTipoEventoInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutTipoEventoInput | EventoCreateOrConnectWithoutTipoEventoInput[]
    createMany?: EventoCreateManyTipoEventoInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type EventoUpdateManyWithoutTipoEventoNestedInput = {
    create?: XOR<EventoCreateWithoutTipoEventoInput, EventoUncheckedCreateWithoutTipoEventoInput> | EventoCreateWithoutTipoEventoInput[] | EventoUncheckedCreateWithoutTipoEventoInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutTipoEventoInput | EventoCreateOrConnectWithoutTipoEventoInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutTipoEventoInput | EventoUpsertWithWhereUniqueWithoutTipoEventoInput[]
    createMany?: EventoCreateManyTipoEventoInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutTipoEventoInput | EventoUpdateWithWhereUniqueWithoutTipoEventoInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutTipoEventoInput | EventoUpdateManyWithWhereWithoutTipoEventoInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type EventoUncheckedUpdateManyWithoutTipoEventoNestedInput = {
    create?: XOR<EventoCreateWithoutTipoEventoInput, EventoUncheckedCreateWithoutTipoEventoInput> | EventoCreateWithoutTipoEventoInput[] | EventoUncheckedCreateWithoutTipoEventoInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutTipoEventoInput | EventoCreateOrConnectWithoutTipoEventoInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutTipoEventoInput | EventoUpsertWithWhereUniqueWithoutTipoEventoInput[]
    createMany?: EventoCreateManyTipoEventoInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutTipoEventoInput | EventoUpdateWithWhereUniqueWithoutTipoEventoInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutTipoEventoInput | EventoUpdateManyWithWhereWithoutTipoEventoInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type EmpleadaRolCreateNestedManyWithoutEmpleadaInput = {
    create?: XOR<EmpleadaRolCreateWithoutEmpleadaInput, EmpleadaRolUncheckedCreateWithoutEmpleadaInput> | EmpleadaRolCreateWithoutEmpleadaInput[] | EmpleadaRolUncheckedCreateWithoutEmpleadaInput[]
    connectOrCreate?: EmpleadaRolCreateOrConnectWithoutEmpleadaInput | EmpleadaRolCreateOrConnectWithoutEmpleadaInput[]
    createMany?: EmpleadaRolCreateManyEmpleadaInputEnvelope
    connect?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
  }

  export type EventoCreateNestedManyWithoutPlannerInput = {
    create?: XOR<EventoCreateWithoutPlannerInput, EventoUncheckedCreateWithoutPlannerInput> | EventoCreateWithoutPlannerInput[] | EventoUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutPlannerInput | EventoCreateOrConnectWithoutPlannerInput[]
    createMany?: EventoCreateManyPlannerInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type EmpleadaRolUncheckedCreateNestedManyWithoutEmpleadaInput = {
    create?: XOR<EmpleadaRolCreateWithoutEmpleadaInput, EmpleadaRolUncheckedCreateWithoutEmpleadaInput> | EmpleadaRolCreateWithoutEmpleadaInput[] | EmpleadaRolUncheckedCreateWithoutEmpleadaInput[]
    connectOrCreate?: EmpleadaRolCreateOrConnectWithoutEmpleadaInput | EmpleadaRolCreateOrConnectWithoutEmpleadaInput[]
    createMany?: EmpleadaRolCreateManyEmpleadaInputEnvelope
    connect?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
  }

  export type EventoUncheckedCreateNestedManyWithoutPlannerInput = {
    create?: XOR<EventoCreateWithoutPlannerInput, EventoUncheckedCreateWithoutPlannerInput> | EventoCreateWithoutPlannerInput[] | EventoUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutPlannerInput | EventoCreateOrConnectWithoutPlannerInput[]
    createMany?: EventoCreateManyPlannerInputEnvelope
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
  }

  export type EmpleadaRolUpdateManyWithoutEmpleadaNestedInput = {
    create?: XOR<EmpleadaRolCreateWithoutEmpleadaInput, EmpleadaRolUncheckedCreateWithoutEmpleadaInput> | EmpleadaRolCreateWithoutEmpleadaInput[] | EmpleadaRolUncheckedCreateWithoutEmpleadaInput[]
    connectOrCreate?: EmpleadaRolCreateOrConnectWithoutEmpleadaInput | EmpleadaRolCreateOrConnectWithoutEmpleadaInput[]
    upsert?: EmpleadaRolUpsertWithWhereUniqueWithoutEmpleadaInput | EmpleadaRolUpsertWithWhereUniqueWithoutEmpleadaInput[]
    createMany?: EmpleadaRolCreateManyEmpleadaInputEnvelope
    set?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    disconnect?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    delete?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    connect?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    update?: EmpleadaRolUpdateWithWhereUniqueWithoutEmpleadaInput | EmpleadaRolUpdateWithWhereUniqueWithoutEmpleadaInput[]
    updateMany?: EmpleadaRolUpdateManyWithWhereWithoutEmpleadaInput | EmpleadaRolUpdateManyWithWhereWithoutEmpleadaInput[]
    deleteMany?: EmpleadaRolScalarWhereInput | EmpleadaRolScalarWhereInput[]
  }

  export type EventoUpdateManyWithoutPlannerNestedInput = {
    create?: XOR<EventoCreateWithoutPlannerInput, EventoUncheckedCreateWithoutPlannerInput> | EventoCreateWithoutPlannerInput[] | EventoUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutPlannerInput | EventoCreateOrConnectWithoutPlannerInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutPlannerInput | EventoUpsertWithWhereUniqueWithoutPlannerInput[]
    createMany?: EventoCreateManyPlannerInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutPlannerInput | EventoUpdateWithWhereUniqueWithoutPlannerInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutPlannerInput | EventoUpdateManyWithWhereWithoutPlannerInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type EmpleadaRolUncheckedUpdateManyWithoutEmpleadaNestedInput = {
    create?: XOR<EmpleadaRolCreateWithoutEmpleadaInput, EmpleadaRolUncheckedCreateWithoutEmpleadaInput> | EmpleadaRolCreateWithoutEmpleadaInput[] | EmpleadaRolUncheckedCreateWithoutEmpleadaInput[]
    connectOrCreate?: EmpleadaRolCreateOrConnectWithoutEmpleadaInput | EmpleadaRolCreateOrConnectWithoutEmpleadaInput[]
    upsert?: EmpleadaRolUpsertWithWhereUniqueWithoutEmpleadaInput | EmpleadaRolUpsertWithWhereUniqueWithoutEmpleadaInput[]
    createMany?: EmpleadaRolCreateManyEmpleadaInputEnvelope
    set?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    disconnect?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    delete?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    connect?: EmpleadaRolWhereUniqueInput | EmpleadaRolWhereUniqueInput[]
    update?: EmpleadaRolUpdateWithWhereUniqueWithoutEmpleadaInput | EmpleadaRolUpdateWithWhereUniqueWithoutEmpleadaInput[]
    updateMany?: EmpleadaRolUpdateManyWithWhereWithoutEmpleadaInput | EmpleadaRolUpdateManyWithWhereWithoutEmpleadaInput[]
    deleteMany?: EmpleadaRolScalarWhereInput | EmpleadaRolScalarWhereInput[]
  }

  export type EventoUncheckedUpdateManyWithoutPlannerNestedInput = {
    create?: XOR<EventoCreateWithoutPlannerInput, EventoUncheckedCreateWithoutPlannerInput> | EventoCreateWithoutPlannerInput[] | EventoUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: EventoCreateOrConnectWithoutPlannerInput | EventoCreateOrConnectWithoutPlannerInput[]
    upsert?: EventoUpsertWithWhereUniqueWithoutPlannerInput | EventoUpsertWithWhereUniqueWithoutPlannerInput[]
    createMany?: EventoCreateManyPlannerInputEnvelope
    set?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    disconnect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    delete?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    connect?: EventoWhereUniqueInput | EventoWhereUniqueInput[]
    update?: EventoUpdateWithWhereUniqueWithoutPlannerInput | EventoUpdateWithWhereUniqueWithoutPlannerInput[]
    updateMany?: EventoUpdateManyWithWhereWithoutPlannerInput | EventoUpdateManyWithWhereWithoutPlannerInput[]
    deleteMany?: EventoScalarWhereInput | EventoScalarWhereInput[]
  }

  export type EmpleadaCreateNestedOneWithoutRolesInput = {
    create?: XOR<EmpleadaCreateWithoutRolesInput, EmpleadaUncheckedCreateWithoutRolesInput>
    connectOrCreate?: EmpleadaCreateOrConnectWithoutRolesInput
    connect?: EmpleadaWhereUniqueInput
  }

  export type EnumRolEmpleadaFieldUpdateOperationsInput = {
    set?: $Enums.RolEmpleada
  }

  export type EmpleadaUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<EmpleadaCreateWithoutRolesInput, EmpleadaUncheckedCreateWithoutRolesInput>
    connectOrCreate?: EmpleadaCreateOrConnectWithoutRolesInput
    upsert?: EmpleadaUpsertWithoutRolesInput
    connect?: EmpleadaWhereUniqueInput
    update?: XOR<XOR<EmpleadaUpdateToOneWithWhereWithoutRolesInput, EmpleadaUpdateWithoutRolesInput>, EmpleadaUncheckedUpdateWithoutRolesInput>
  }

  export type CatMovCreateNestedOneWithoutMovimientosInput = {
    create?: XOR<CatMovCreateWithoutMovimientosInput, CatMovUncheckedCreateWithoutMovimientosInput>
    connectOrCreate?: CatMovCreateOrConnectWithoutMovimientosInput
    connect?: CatMovWhereUniqueInput
  }

  export type SubcatMovimientoCreateNestedOneWithoutMovimientosInput = {
    create?: XOR<SubcatMovimientoCreateWithoutMovimientosInput, SubcatMovimientoUncheckedCreateWithoutMovimientosInput>
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutMovimientosInput
    connect?: SubcatMovimientoWhereUniqueInput
  }

  export type DetMovCreateNestedOneWithoutMovimientosInput = {
    create?: XOR<DetMovCreateWithoutMovimientosInput, DetMovUncheckedCreateWithoutMovimientosInput>
    connectOrCreate?: DetMovCreateOrConnectWithoutMovimientosInput
    connect?: DetMovWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumMonedaFieldUpdateOperationsInput = {
    set?: $Enums.Moneda
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CatMovUpdateOneRequiredWithoutMovimientosNestedInput = {
    create?: XOR<CatMovCreateWithoutMovimientosInput, CatMovUncheckedCreateWithoutMovimientosInput>
    connectOrCreate?: CatMovCreateOrConnectWithoutMovimientosInput
    upsert?: CatMovUpsertWithoutMovimientosInput
    connect?: CatMovWhereUniqueInput
    update?: XOR<XOR<CatMovUpdateToOneWithWhereWithoutMovimientosInput, CatMovUpdateWithoutMovimientosInput>, CatMovUncheckedUpdateWithoutMovimientosInput>
  }

  export type SubcatMovimientoUpdateOneRequiredWithoutMovimientosNestedInput = {
    create?: XOR<SubcatMovimientoCreateWithoutMovimientosInput, SubcatMovimientoUncheckedCreateWithoutMovimientosInput>
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutMovimientosInput
    upsert?: SubcatMovimientoUpsertWithoutMovimientosInput
    connect?: SubcatMovimientoWhereUniqueInput
    update?: XOR<XOR<SubcatMovimientoUpdateToOneWithWhereWithoutMovimientosInput, SubcatMovimientoUpdateWithoutMovimientosInput>, SubcatMovimientoUncheckedUpdateWithoutMovimientosInput>
  }

  export type DetMovUpdateOneRequiredWithoutMovimientosNestedInput = {
    create?: XOR<DetMovCreateWithoutMovimientosInput, DetMovUncheckedCreateWithoutMovimientosInput>
    connectOrCreate?: DetMovCreateOrConnectWithoutMovimientosInput
    upsert?: DetMovUpsertWithoutMovimientosInput
    connect?: DetMovWhereUniqueInput
    update?: XOR<XOR<DetMovUpdateToOneWithWhereWithoutMovimientosInput, DetMovUpdateWithoutMovimientosInput>, DetMovUncheckedUpdateWithoutMovimientosInput>
  }

  export type MovimientoCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<MovimientoCreateWithoutCategoriaInput, MovimientoUncheckedCreateWithoutCategoriaInput> | MovimientoCreateWithoutCategoriaInput[] | MovimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutCategoriaInput | MovimientoCreateOrConnectWithoutCategoriaInput[]
    createMany?: MovimientoCreateManyCategoriaInputEnvelope
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
  }

  export type SubcatMovimientoCreateNestedManyWithoutCatMovInput = {
    create?: XOR<SubcatMovimientoCreateWithoutCatMovInput, SubcatMovimientoUncheckedCreateWithoutCatMovInput> | SubcatMovimientoCreateWithoutCatMovInput[] | SubcatMovimientoUncheckedCreateWithoutCatMovInput[]
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutCatMovInput | SubcatMovimientoCreateOrConnectWithoutCatMovInput[]
    createMany?: SubcatMovimientoCreateManyCatMovInputEnvelope
    connect?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
  }

  export type MovimientoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<MovimientoCreateWithoutCategoriaInput, MovimientoUncheckedCreateWithoutCategoriaInput> | MovimientoCreateWithoutCategoriaInput[] | MovimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutCategoriaInput | MovimientoCreateOrConnectWithoutCategoriaInput[]
    createMany?: MovimientoCreateManyCategoriaInputEnvelope
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
  }

  export type SubcatMovimientoUncheckedCreateNestedManyWithoutCatMovInput = {
    create?: XOR<SubcatMovimientoCreateWithoutCatMovInput, SubcatMovimientoUncheckedCreateWithoutCatMovInput> | SubcatMovimientoCreateWithoutCatMovInput[] | SubcatMovimientoUncheckedCreateWithoutCatMovInput[]
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutCatMovInput | SubcatMovimientoCreateOrConnectWithoutCatMovInput[]
    createMany?: SubcatMovimientoCreateManyCatMovInputEnvelope
    connect?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
  }

  export type MovimientoUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<MovimientoCreateWithoutCategoriaInput, MovimientoUncheckedCreateWithoutCategoriaInput> | MovimientoCreateWithoutCategoriaInput[] | MovimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutCategoriaInput | MovimientoCreateOrConnectWithoutCategoriaInput[]
    upsert?: MovimientoUpsertWithWhereUniqueWithoutCategoriaInput | MovimientoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: MovimientoCreateManyCategoriaInputEnvelope
    set?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    disconnect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    delete?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    update?: MovimientoUpdateWithWhereUniqueWithoutCategoriaInput | MovimientoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: MovimientoUpdateManyWithWhereWithoutCategoriaInput | MovimientoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
  }

  export type SubcatMovimientoUpdateManyWithoutCatMovNestedInput = {
    create?: XOR<SubcatMovimientoCreateWithoutCatMovInput, SubcatMovimientoUncheckedCreateWithoutCatMovInput> | SubcatMovimientoCreateWithoutCatMovInput[] | SubcatMovimientoUncheckedCreateWithoutCatMovInput[]
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutCatMovInput | SubcatMovimientoCreateOrConnectWithoutCatMovInput[]
    upsert?: SubcatMovimientoUpsertWithWhereUniqueWithoutCatMovInput | SubcatMovimientoUpsertWithWhereUniqueWithoutCatMovInput[]
    createMany?: SubcatMovimientoCreateManyCatMovInputEnvelope
    set?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    disconnect?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    delete?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    connect?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    update?: SubcatMovimientoUpdateWithWhereUniqueWithoutCatMovInput | SubcatMovimientoUpdateWithWhereUniqueWithoutCatMovInput[]
    updateMany?: SubcatMovimientoUpdateManyWithWhereWithoutCatMovInput | SubcatMovimientoUpdateManyWithWhereWithoutCatMovInput[]
    deleteMany?: SubcatMovimientoScalarWhereInput | SubcatMovimientoScalarWhereInput[]
  }

  export type MovimientoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<MovimientoCreateWithoutCategoriaInput, MovimientoUncheckedCreateWithoutCategoriaInput> | MovimientoCreateWithoutCategoriaInput[] | MovimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutCategoriaInput | MovimientoCreateOrConnectWithoutCategoriaInput[]
    upsert?: MovimientoUpsertWithWhereUniqueWithoutCategoriaInput | MovimientoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: MovimientoCreateManyCategoriaInputEnvelope
    set?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    disconnect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    delete?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    update?: MovimientoUpdateWithWhereUniqueWithoutCategoriaInput | MovimientoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: MovimientoUpdateManyWithWhereWithoutCategoriaInput | MovimientoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
  }

  export type SubcatMovimientoUncheckedUpdateManyWithoutCatMovNestedInput = {
    create?: XOR<SubcatMovimientoCreateWithoutCatMovInput, SubcatMovimientoUncheckedCreateWithoutCatMovInput> | SubcatMovimientoCreateWithoutCatMovInput[] | SubcatMovimientoUncheckedCreateWithoutCatMovInput[]
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutCatMovInput | SubcatMovimientoCreateOrConnectWithoutCatMovInput[]
    upsert?: SubcatMovimientoUpsertWithWhereUniqueWithoutCatMovInput | SubcatMovimientoUpsertWithWhereUniqueWithoutCatMovInput[]
    createMany?: SubcatMovimientoCreateManyCatMovInputEnvelope
    set?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    disconnect?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    delete?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    connect?: SubcatMovimientoWhereUniqueInput | SubcatMovimientoWhereUniqueInput[]
    update?: SubcatMovimientoUpdateWithWhereUniqueWithoutCatMovInput | SubcatMovimientoUpdateWithWhereUniqueWithoutCatMovInput[]
    updateMany?: SubcatMovimientoUpdateManyWithWhereWithoutCatMovInput | SubcatMovimientoUpdateManyWithWhereWithoutCatMovInput[]
    deleteMany?: SubcatMovimientoScalarWhereInput | SubcatMovimientoScalarWhereInput[]
  }

  export type CatMovCreateNestedOneWithoutSubcategoriasInput = {
    create?: XOR<CatMovCreateWithoutSubcategoriasInput, CatMovUncheckedCreateWithoutSubcategoriasInput>
    connectOrCreate?: CatMovCreateOrConnectWithoutSubcategoriasInput
    connect?: CatMovWhereUniqueInput
  }

  export type MovimientoCreateNestedManyWithoutSubcategoriaInput = {
    create?: XOR<MovimientoCreateWithoutSubcategoriaInput, MovimientoUncheckedCreateWithoutSubcategoriaInput> | MovimientoCreateWithoutSubcategoriaInput[] | MovimientoUncheckedCreateWithoutSubcategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutSubcategoriaInput | MovimientoCreateOrConnectWithoutSubcategoriaInput[]
    createMany?: MovimientoCreateManySubcategoriaInputEnvelope
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
  }

  export type DetMovCreateNestedManyWithoutSubcatMovimientoInput = {
    create?: XOR<DetMovCreateWithoutSubcatMovimientoInput, DetMovUncheckedCreateWithoutSubcatMovimientoInput> | DetMovCreateWithoutSubcatMovimientoInput[] | DetMovUncheckedCreateWithoutSubcatMovimientoInput[]
    connectOrCreate?: DetMovCreateOrConnectWithoutSubcatMovimientoInput | DetMovCreateOrConnectWithoutSubcatMovimientoInput[]
    createMany?: DetMovCreateManySubcatMovimientoInputEnvelope
    connect?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
  }

  export type MovimientoUncheckedCreateNestedManyWithoutSubcategoriaInput = {
    create?: XOR<MovimientoCreateWithoutSubcategoriaInput, MovimientoUncheckedCreateWithoutSubcategoriaInput> | MovimientoCreateWithoutSubcategoriaInput[] | MovimientoUncheckedCreateWithoutSubcategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutSubcategoriaInput | MovimientoCreateOrConnectWithoutSubcategoriaInput[]
    createMany?: MovimientoCreateManySubcategoriaInputEnvelope
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
  }

  export type DetMovUncheckedCreateNestedManyWithoutSubcatMovimientoInput = {
    create?: XOR<DetMovCreateWithoutSubcatMovimientoInput, DetMovUncheckedCreateWithoutSubcatMovimientoInput> | DetMovCreateWithoutSubcatMovimientoInput[] | DetMovUncheckedCreateWithoutSubcatMovimientoInput[]
    connectOrCreate?: DetMovCreateOrConnectWithoutSubcatMovimientoInput | DetMovCreateOrConnectWithoutSubcatMovimientoInput[]
    createMany?: DetMovCreateManySubcatMovimientoInputEnvelope
    connect?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
  }

  export type CatMovUpdateOneRequiredWithoutSubcategoriasNestedInput = {
    create?: XOR<CatMovCreateWithoutSubcategoriasInput, CatMovUncheckedCreateWithoutSubcategoriasInput>
    connectOrCreate?: CatMovCreateOrConnectWithoutSubcategoriasInput
    upsert?: CatMovUpsertWithoutSubcategoriasInput
    connect?: CatMovWhereUniqueInput
    update?: XOR<XOR<CatMovUpdateToOneWithWhereWithoutSubcategoriasInput, CatMovUpdateWithoutSubcategoriasInput>, CatMovUncheckedUpdateWithoutSubcategoriasInput>
  }

  export type MovimientoUpdateManyWithoutSubcategoriaNestedInput = {
    create?: XOR<MovimientoCreateWithoutSubcategoriaInput, MovimientoUncheckedCreateWithoutSubcategoriaInput> | MovimientoCreateWithoutSubcategoriaInput[] | MovimientoUncheckedCreateWithoutSubcategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutSubcategoriaInput | MovimientoCreateOrConnectWithoutSubcategoriaInput[]
    upsert?: MovimientoUpsertWithWhereUniqueWithoutSubcategoriaInput | MovimientoUpsertWithWhereUniqueWithoutSubcategoriaInput[]
    createMany?: MovimientoCreateManySubcategoriaInputEnvelope
    set?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    disconnect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    delete?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    update?: MovimientoUpdateWithWhereUniqueWithoutSubcategoriaInput | MovimientoUpdateWithWhereUniqueWithoutSubcategoriaInput[]
    updateMany?: MovimientoUpdateManyWithWhereWithoutSubcategoriaInput | MovimientoUpdateManyWithWhereWithoutSubcategoriaInput[]
    deleteMany?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
  }

  export type DetMovUpdateManyWithoutSubcatMovimientoNestedInput = {
    create?: XOR<DetMovCreateWithoutSubcatMovimientoInput, DetMovUncheckedCreateWithoutSubcatMovimientoInput> | DetMovCreateWithoutSubcatMovimientoInput[] | DetMovUncheckedCreateWithoutSubcatMovimientoInput[]
    connectOrCreate?: DetMovCreateOrConnectWithoutSubcatMovimientoInput | DetMovCreateOrConnectWithoutSubcatMovimientoInput[]
    upsert?: DetMovUpsertWithWhereUniqueWithoutSubcatMovimientoInput | DetMovUpsertWithWhereUniqueWithoutSubcatMovimientoInput[]
    createMany?: DetMovCreateManySubcatMovimientoInputEnvelope
    set?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    disconnect?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    delete?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    connect?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    update?: DetMovUpdateWithWhereUniqueWithoutSubcatMovimientoInput | DetMovUpdateWithWhereUniqueWithoutSubcatMovimientoInput[]
    updateMany?: DetMovUpdateManyWithWhereWithoutSubcatMovimientoInput | DetMovUpdateManyWithWhereWithoutSubcatMovimientoInput[]
    deleteMany?: DetMovScalarWhereInput | DetMovScalarWhereInput[]
  }

  export type MovimientoUncheckedUpdateManyWithoutSubcategoriaNestedInput = {
    create?: XOR<MovimientoCreateWithoutSubcategoriaInput, MovimientoUncheckedCreateWithoutSubcategoriaInput> | MovimientoCreateWithoutSubcategoriaInput[] | MovimientoUncheckedCreateWithoutSubcategoriaInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutSubcategoriaInput | MovimientoCreateOrConnectWithoutSubcategoriaInput[]
    upsert?: MovimientoUpsertWithWhereUniqueWithoutSubcategoriaInput | MovimientoUpsertWithWhereUniqueWithoutSubcategoriaInput[]
    createMany?: MovimientoCreateManySubcategoriaInputEnvelope
    set?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    disconnect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    delete?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    update?: MovimientoUpdateWithWhereUniqueWithoutSubcategoriaInput | MovimientoUpdateWithWhereUniqueWithoutSubcategoriaInput[]
    updateMany?: MovimientoUpdateManyWithWhereWithoutSubcategoriaInput | MovimientoUpdateManyWithWhereWithoutSubcategoriaInput[]
    deleteMany?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
  }

  export type DetMovUncheckedUpdateManyWithoutSubcatMovimientoNestedInput = {
    create?: XOR<DetMovCreateWithoutSubcatMovimientoInput, DetMovUncheckedCreateWithoutSubcatMovimientoInput> | DetMovCreateWithoutSubcatMovimientoInput[] | DetMovUncheckedCreateWithoutSubcatMovimientoInput[]
    connectOrCreate?: DetMovCreateOrConnectWithoutSubcatMovimientoInput | DetMovCreateOrConnectWithoutSubcatMovimientoInput[]
    upsert?: DetMovUpsertWithWhereUniqueWithoutSubcatMovimientoInput | DetMovUpsertWithWhereUniqueWithoutSubcatMovimientoInput[]
    createMany?: DetMovCreateManySubcatMovimientoInputEnvelope
    set?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    disconnect?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    delete?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    connect?: DetMovWhereUniqueInput | DetMovWhereUniqueInput[]
    update?: DetMovUpdateWithWhereUniqueWithoutSubcatMovimientoInput | DetMovUpdateWithWhereUniqueWithoutSubcatMovimientoInput[]
    updateMany?: DetMovUpdateManyWithWhereWithoutSubcatMovimientoInput | DetMovUpdateManyWithWhereWithoutSubcatMovimientoInput[]
    deleteMany?: DetMovScalarWhereInput | DetMovScalarWhereInput[]
  }

  export type SubcatMovimientoCreateNestedOneWithoutDetallesInput = {
    create?: XOR<SubcatMovimientoCreateWithoutDetallesInput, SubcatMovimientoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutDetallesInput
    connect?: SubcatMovimientoWhereUniqueInput
  }

  export type MovimientoCreateNestedManyWithoutDetalleInput = {
    create?: XOR<MovimientoCreateWithoutDetalleInput, MovimientoUncheckedCreateWithoutDetalleInput> | MovimientoCreateWithoutDetalleInput[] | MovimientoUncheckedCreateWithoutDetalleInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutDetalleInput | MovimientoCreateOrConnectWithoutDetalleInput[]
    createMany?: MovimientoCreateManyDetalleInputEnvelope
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
  }

  export type MovimientoUncheckedCreateNestedManyWithoutDetalleInput = {
    create?: XOR<MovimientoCreateWithoutDetalleInput, MovimientoUncheckedCreateWithoutDetalleInput> | MovimientoCreateWithoutDetalleInput[] | MovimientoUncheckedCreateWithoutDetalleInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutDetalleInput | MovimientoCreateOrConnectWithoutDetalleInput[]
    createMany?: MovimientoCreateManyDetalleInputEnvelope
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
  }

  export type SubcatMovimientoUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<SubcatMovimientoCreateWithoutDetallesInput, SubcatMovimientoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: SubcatMovimientoCreateOrConnectWithoutDetallesInput
    upsert?: SubcatMovimientoUpsertWithoutDetallesInput
    connect?: SubcatMovimientoWhereUniqueInput
    update?: XOR<XOR<SubcatMovimientoUpdateToOneWithWhereWithoutDetallesInput, SubcatMovimientoUpdateWithoutDetallesInput>, SubcatMovimientoUncheckedUpdateWithoutDetallesInput>
  }

  export type MovimientoUpdateManyWithoutDetalleNestedInput = {
    create?: XOR<MovimientoCreateWithoutDetalleInput, MovimientoUncheckedCreateWithoutDetalleInput> | MovimientoCreateWithoutDetalleInput[] | MovimientoUncheckedCreateWithoutDetalleInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutDetalleInput | MovimientoCreateOrConnectWithoutDetalleInput[]
    upsert?: MovimientoUpsertWithWhereUniqueWithoutDetalleInput | MovimientoUpsertWithWhereUniqueWithoutDetalleInput[]
    createMany?: MovimientoCreateManyDetalleInputEnvelope
    set?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    disconnect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    delete?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    update?: MovimientoUpdateWithWhereUniqueWithoutDetalleInput | MovimientoUpdateWithWhereUniqueWithoutDetalleInput[]
    updateMany?: MovimientoUpdateManyWithWhereWithoutDetalleInput | MovimientoUpdateManyWithWhereWithoutDetalleInput[]
    deleteMany?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
  }

  export type MovimientoUncheckedUpdateManyWithoutDetalleNestedInput = {
    create?: XOR<MovimientoCreateWithoutDetalleInput, MovimientoUncheckedCreateWithoutDetalleInput> | MovimientoCreateWithoutDetalleInput[] | MovimientoUncheckedCreateWithoutDetalleInput[]
    connectOrCreate?: MovimientoCreateOrConnectWithoutDetalleInput | MovimientoCreateOrConnectWithoutDetalleInput[]
    upsert?: MovimientoUpsertWithWhereUniqueWithoutDetalleInput | MovimientoUpsertWithWhereUniqueWithoutDetalleInput[]
    createMany?: MovimientoCreateManyDetalleInputEnvelope
    set?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    disconnect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    delete?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    connect?: MovimientoWhereUniqueInput | MovimientoWhereUniqueInput[]
    update?: MovimientoUpdateWithWhereUniqueWithoutDetalleInput | MovimientoUpdateWithWhereUniqueWithoutDetalleInput[]
    updateMany?: MovimientoUpdateManyWithWhereWithoutDetalleInput | MovimientoUpdateManyWithWhereWithoutDetalleInput[]
    deleteMany?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRolEmpleadaFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEmpleada | EnumRolEmpleadaFieldRefInput<$PrismaModel>
    in?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEmpleadaFilter<$PrismaModel> | $Enums.RolEmpleada
  }

  export type NestedEnumRolEmpleadaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEmpleada | EnumRolEmpleadaFieldRefInput<$PrismaModel>
    in?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEmpleada[] | ListEnumRolEmpleadaFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEmpleadaWithAggregatesFilter<$PrismaModel> | $Enums.RolEmpleada
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolEmpleadaFilter<$PrismaModel>
    _max?: NestedEnumRolEmpleadaFilter<$PrismaModel>
  }

  export type NestedEnumMonedaFilter<$PrismaModel = never> = {
    equals?: $Enums.Moneda | EnumMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumMonedaFilter<$PrismaModel> | $Enums.Moneda
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMonedaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Moneda | EnumMonedaFieldRefInput<$PrismaModel>
    in?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Moneda[] | ListEnumMonedaFieldRefInput<$PrismaModel>
    not?: NestedEnumMonedaWithAggregatesFilter<$PrismaModel> | $Enums.Moneda
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMonedaFilter<$PrismaModel>
    _max?: NestedEnumMonedaFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ClienteCreateWithoutPersonasInput = {
    id?: string
    nombre: string
    email: string
    ciudad: CiudadCreateNestedOneWithoutClientesInput
    eventos?: EventoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutPersonasInput = {
    id?: string
    nombre: string
    email: string
    ciudadId: string
    eventos?: EventoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutPersonasInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutPersonasInput, ClienteUncheckedCreateWithoutPersonasInput>
  }

  export type ClienteUpsertWithoutPersonasInput = {
    update: XOR<ClienteUpdateWithoutPersonasInput, ClienteUncheckedUpdateWithoutPersonasInput>
    create: XOR<ClienteCreateWithoutPersonasInput, ClienteUncheckedCreateWithoutPersonasInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutPersonasInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutPersonasInput, ClienteUncheckedUpdateWithoutPersonasInput>
  }

  export type ClienteUpdateWithoutPersonasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ciudad?: CiudadUpdateOneRequiredWithoutClientesNestedInput
    eventos?: EventoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutPersonasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ciudadId?: StringFieldUpdateOperationsInput | string
    eventos?: EventoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type CiudadCreateWithoutClientesInput = {
    id?: string
    nombre: string
  }

  export type CiudadUncheckedCreateWithoutClientesInput = {
    id?: string
    nombre: string
  }

  export type CiudadCreateOrConnectWithoutClientesInput = {
    where: CiudadWhereUniqueInput
    create: XOR<CiudadCreateWithoutClientesInput, CiudadUncheckedCreateWithoutClientesInput>
  }

  export type PersonaCreateWithoutClienteInput = {
    id?: string
    nombre: string
    apellido: string
    telefono?: string | null
    email?: string | null
    cumpleanos?: Date | string | null
    eventoCalendarioId?: string | null
  }

  export type PersonaUncheckedCreateWithoutClienteInput = {
    id?: string
    nombre: string
    apellido: string
    telefono?: string | null
    email?: string | null
    cumpleanos?: Date | string | null
    eventoCalendarioId?: string | null
  }

  export type PersonaCreateOrConnectWithoutClienteInput = {
    where: PersonaWhereUniqueInput
    create: XOR<PersonaCreateWithoutClienteInput, PersonaUncheckedCreateWithoutClienteInput>
  }

  export type PersonaCreateManyClienteInputEnvelope = {
    data: PersonaCreateManyClienteInput | PersonaCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type EventoCreateWithoutClienteInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    carpetaId?: string | null
    estado: string
    tipoEvento: TipoEventoCreateNestedOneWithoutEventosInput
    planner: EmpleadaCreateNestedOneWithoutEventosInput
  }

  export type EventoUncheckedCreateWithoutClienteInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    tipoEventoId: string
    carpetaId?: string | null
    estado: string
    plannerId: string
  }

  export type EventoCreateOrConnectWithoutClienteInput = {
    where: EventoWhereUniqueInput
    create: XOR<EventoCreateWithoutClienteInput, EventoUncheckedCreateWithoutClienteInput>
  }

  export type EventoCreateManyClienteInputEnvelope = {
    data: EventoCreateManyClienteInput | EventoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type CiudadUpsertWithoutClientesInput = {
    update: XOR<CiudadUpdateWithoutClientesInput, CiudadUncheckedUpdateWithoutClientesInput>
    create: XOR<CiudadCreateWithoutClientesInput, CiudadUncheckedCreateWithoutClientesInput>
    where?: CiudadWhereInput
  }

  export type CiudadUpdateToOneWithWhereWithoutClientesInput = {
    where?: CiudadWhereInput
    data: XOR<CiudadUpdateWithoutClientesInput, CiudadUncheckedUpdateWithoutClientesInput>
  }

  export type CiudadUpdateWithoutClientesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CiudadUncheckedUpdateWithoutClientesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type PersonaUpsertWithWhereUniqueWithoutClienteInput = {
    where: PersonaWhereUniqueInput
    update: XOR<PersonaUpdateWithoutClienteInput, PersonaUncheckedUpdateWithoutClienteInput>
    create: XOR<PersonaCreateWithoutClienteInput, PersonaUncheckedCreateWithoutClienteInput>
  }

  export type PersonaUpdateWithWhereUniqueWithoutClienteInput = {
    where: PersonaWhereUniqueInput
    data: XOR<PersonaUpdateWithoutClienteInput, PersonaUncheckedUpdateWithoutClienteInput>
  }

  export type PersonaUpdateManyWithWhereWithoutClienteInput = {
    where: PersonaScalarWhereInput
    data: XOR<PersonaUpdateManyMutationInput, PersonaUncheckedUpdateManyWithoutClienteInput>
  }

  export type PersonaScalarWhereInput = {
    AND?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
    OR?: PersonaScalarWhereInput[]
    NOT?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
    id?: StringFilter<"Persona"> | string
    nombre?: StringFilter<"Persona"> | string
    apellido?: StringFilter<"Persona"> | string
    telefono?: StringNullableFilter<"Persona"> | string | null
    email?: StringNullableFilter<"Persona"> | string | null
    cumpleanos?: DateTimeNullableFilter<"Persona"> | Date | string | null
    eventoCalendarioId?: StringNullableFilter<"Persona"> | string | null
    clienteId?: StringNullableFilter<"Persona"> | string | null
  }

  export type EventoUpsertWithWhereUniqueWithoutClienteInput = {
    where: EventoWhereUniqueInput
    update: XOR<EventoUpdateWithoutClienteInput, EventoUncheckedUpdateWithoutClienteInput>
    create: XOR<EventoCreateWithoutClienteInput, EventoUncheckedCreateWithoutClienteInput>
  }

  export type EventoUpdateWithWhereUniqueWithoutClienteInput = {
    where: EventoWhereUniqueInput
    data: XOR<EventoUpdateWithoutClienteInput, EventoUncheckedUpdateWithoutClienteInput>
  }

  export type EventoUpdateManyWithWhereWithoutClienteInput = {
    where: EventoScalarWhereInput
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyWithoutClienteInput>
  }

  export type EventoScalarWhereInput = {
    AND?: EventoScalarWhereInput | EventoScalarWhereInput[]
    OR?: EventoScalarWhereInput[]
    NOT?: EventoScalarWhereInput | EventoScalarWhereInput[]
    id?: StringFilter<"Evento"> | string
    fecha?: DateTimeFilter<"Evento"> | Date | string
    numInvitados?: IntFilter<"Evento"> | number
    tipoEventoId?: StringFilter<"Evento"> | string
    clienteId?: StringFilter<"Evento"> | string
    carpetaId?: StringNullableFilter<"Evento"> | string | null
    estado?: StringFilter<"Evento"> | string
    plannerId?: StringFilter<"Evento"> | string
  }

  export type ClienteCreateWithoutCiudadInput = {
    id?: string
    nombre: string
    email: string
    personas?: PersonaCreateNestedManyWithoutClienteInput
    eventos?: EventoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutCiudadInput = {
    id?: string
    nombre: string
    email: string
    personas?: PersonaUncheckedCreateNestedManyWithoutClienteInput
    eventos?: EventoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutCiudadInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutCiudadInput, ClienteUncheckedCreateWithoutCiudadInput>
  }

  export type ClienteCreateManyCiudadInputEnvelope = {
    data: ClienteCreateManyCiudadInput | ClienteCreateManyCiudadInput[]
    skipDuplicates?: boolean
  }

  export type ClienteUpsertWithWhereUniqueWithoutCiudadInput = {
    where: ClienteWhereUniqueInput
    update: XOR<ClienteUpdateWithoutCiudadInput, ClienteUncheckedUpdateWithoutCiudadInput>
    create: XOR<ClienteCreateWithoutCiudadInput, ClienteUncheckedCreateWithoutCiudadInput>
  }

  export type ClienteUpdateWithWhereUniqueWithoutCiudadInput = {
    where: ClienteWhereUniqueInput
    data: XOR<ClienteUpdateWithoutCiudadInput, ClienteUncheckedUpdateWithoutCiudadInput>
  }

  export type ClienteUpdateManyWithWhereWithoutCiudadInput = {
    where: ClienteScalarWhereInput
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyWithoutCiudadInput>
  }

  export type ClienteScalarWhereInput = {
    AND?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
    OR?: ClienteScalarWhereInput[]
    NOT?: ClienteScalarWhereInput | ClienteScalarWhereInput[]
    id?: StringFilter<"Cliente"> | string
    nombre?: StringFilter<"Cliente"> | string
    email?: StringFilter<"Cliente"> | string
    ciudadId?: StringFilter<"Cliente"> | string
  }

  export type TipoEventoCreateWithoutEventosInput = {
    id?: string
    nombre: string
  }

  export type TipoEventoUncheckedCreateWithoutEventosInput = {
    id?: string
    nombre: string
  }

  export type TipoEventoCreateOrConnectWithoutEventosInput = {
    where: TipoEventoWhereUniqueInput
    create: XOR<TipoEventoCreateWithoutEventosInput, TipoEventoUncheckedCreateWithoutEventosInput>
  }

  export type ClienteCreateWithoutEventosInput = {
    id?: string
    nombre: string
    email: string
    ciudad: CiudadCreateNestedOneWithoutClientesInput
    personas?: PersonaCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutEventosInput = {
    id?: string
    nombre: string
    email: string
    ciudadId: string
    personas?: PersonaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutEventosInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutEventosInput, ClienteUncheckedCreateWithoutEventosInput>
  }

  export type EmpleadaCreateWithoutEventosInput = {
    id?: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
    roles?: EmpleadaRolCreateNestedManyWithoutEmpleadaInput
  }

  export type EmpleadaUncheckedCreateWithoutEventosInput = {
    id?: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
    roles?: EmpleadaRolUncheckedCreateNestedManyWithoutEmpleadaInput
  }

  export type EmpleadaCreateOrConnectWithoutEventosInput = {
    where: EmpleadaWhereUniqueInput
    create: XOR<EmpleadaCreateWithoutEventosInput, EmpleadaUncheckedCreateWithoutEventosInput>
  }

  export type TipoEventoUpsertWithoutEventosInput = {
    update: XOR<TipoEventoUpdateWithoutEventosInput, TipoEventoUncheckedUpdateWithoutEventosInput>
    create: XOR<TipoEventoCreateWithoutEventosInput, TipoEventoUncheckedCreateWithoutEventosInput>
    where?: TipoEventoWhereInput
  }

  export type TipoEventoUpdateToOneWithWhereWithoutEventosInput = {
    where?: TipoEventoWhereInput
    data: XOR<TipoEventoUpdateWithoutEventosInput, TipoEventoUncheckedUpdateWithoutEventosInput>
  }

  export type TipoEventoUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type TipoEventoUncheckedUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type ClienteUpsertWithoutEventosInput = {
    update: XOR<ClienteUpdateWithoutEventosInput, ClienteUncheckedUpdateWithoutEventosInput>
    create: XOR<ClienteCreateWithoutEventosInput, ClienteUncheckedCreateWithoutEventosInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutEventosInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutEventosInput, ClienteUncheckedUpdateWithoutEventosInput>
  }

  export type ClienteUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ciudad?: CiudadUpdateOneRequiredWithoutClientesNestedInput
    personas?: PersonaUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ciudadId?: StringFieldUpdateOperationsInput | string
    personas?: PersonaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type EmpleadaUpsertWithoutEventosInput = {
    update: XOR<EmpleadaUpdateWithoutEventosInput, EmpleadaUncheckedUpdateWithoutEventosInput>
    create: XOR<EmpleadaCreateWithoutEventosInput, EmpleadaUncheckedCreateWithoutEventosInput>
    where?: EmpleadaWhereInput
  }

  export type EmpleadaUpdateToOneWithWhereWithoutEventosInput = {
    where?: EmpleadaWhereInput
    data: XOR<EmpleadaUpdateWithoutEventosInput, EmpleadaUncheckedUpdateWithoutEventosInput>
  }

  export type EmpleadaUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    roles?: EmpleadaRolUpdateManyWithoutEmpleadaNestedInput
  }

  export type EmpleadaUncheckedUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    roles?: EmpleadaRolUncheckedUpdateManyWithoutEmpleadaNestedInput
  }

  export type EventoCreateWithoutTipoEventoInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    carpetaId?: string | null
    estado: string
    cliente: ClienteCreateNestedOneWithoutEventosInput
    planner: EmpleadaCreateNestedOneWithoutEventosInput
  }

  export type EventoUncheckedCreateWithoutTipoEventoInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    clienteId: string
    carpetaId?: string | null
    estado: string
    plannerId: string
  }

  export type EventoCreateOrConnectWithoutTipoEventoInput = {
    where: EventoWhereUniqueInput
    create: XOR<EventoCreateWithoutTipoEventoInput, EventoUncheckedCreateWithoutTipoEventoInput>
  }

  export type EventoCreateManyTipoEventoInputEnvelope = {
    data: EventoCreateManyTipoEventoInput | EventoCreateManyTipoEventoInput[]
    skipDuplicates?: boolean
  }

  export type EventoUpsertWithWhereUniqueWithoutTipoEventoInput = {
    where: EventoWhereUniqueInput
    update: XOR<EventoUpdateWithoutTipoEventoInput, EventoUncheckedUpdateWithoutTipoEventoInput>
    create: XOR<EventoCreateWithoutTipoEventoInput, EventoUncheckedCreateWithoutTipoEventoInput>
  }

  export type EventoUpdateWithWhereUniqueWithoutTipoEventoInput = {
    where: EventoWhereUniqueInput
    data: XOR<EventoUpdateWithoutTipoEventoInput, EventoUncheckedUpdateWithoutTipoEventoInput>
  }

  export type EventoUpdateManyWithWhereWithoutTipoEventoInput = {
    where: EventoScalarWhereInput
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyWithoutTipoEventoInput>
  }

  export type EmpleadaRolCreateWithoutEmpleadaInput = {
    id?: string
    rol: $Enums.RolEmpleada
  }

  export type EmpleadaRolUncheckedCreateWithoutEmpleadaInput = {
    id?: string
    rol: $Enums.RolEmpleada
  }

  export type EmpleadaRolCreateOrConnectWithoutEmpleadaInput = {
    where: EmpleadaRolWhereUniqueInput
    create: XOR<EmpleadaRolCreateWithoutEmpleadaInput, EmpleadaRolUncheckedCreateWithoutEmpleadaInput>
  }

  export type EmpleadaRolCreateManyEmpleadaInputEnvelope = {
    data: EmpleadaRolCreateManyEmpleadaInput | EmpleadaRolCreateManyEmpleadaInput[]
    skipDuplicates?: boolean
  }

  export type EventoCreateWithoutPlannerInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    carpetaId?: string | null
    estado: string
    tipoEvento: TipoEventoCreateNestedOneWithoutEventosInput
    cliente: ClienteCreateNestedOneWithoutEventosInput
  }

  export type EventoUncheckedCreateWithoutPlannerInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    tipoEventoId: string
    clienteId: string
    carpetaId?: string | null
    estado: string
  }

  export type EventoCreateOrConnectWithoutPlannerInput = {
    where: EventoWhereUniqueInput
    create: XOR<EventoCreateWithoutPlannerInput, EventoUncheckedCreateWithoutPlannerInput>
  }

  export type EventoCreateManyPlannerInputEnvelope = {
    data: EventoCreateManyPlannerInput | EventoCreateManyPlannerInput[]
    skipDuplicates?: boolean
  }

  export type EmpleadaRolUpsertWithWhereUniqueWithoutEmpleadaInput = {
    where: EmpleadaRolWhereUniqueInput
    update: XOR<EmpleadaRolUpdateWithoutEmpleadaInput, EmpleadaRolUncheckedUpdateWithoutEmpleadaInput>
    create: XOR<EmpleadaRolCreateWithoutEmpleadaInput, EmpleadaRolUncheckedCreateWithoutEmpleadaInput>
  }

  export type EmpleadaRolUpdateWithWhereUniqueWithoutEmpleadaInput = {
    where: EmpleadaRolWhereUniqueInput
    data: XOR<EmpleadaRolUpdateWithoutEmpleadaInput, EmpleadaRolUncheckedUpdateWithoutEmpleadaInput>
  }

  export type EmpleadaRolUpdateManyWithWhereWithoutEmpleadaInput = {
    where: EmpleadaRolScalarWhereInput
    data: XOR<EmpleadaRolUpdateManyMutationInput, EmpleadaRolUncheckedUpdateManyWithoutEmpleadaInput>
  }

  export type EmpleadaRolScalarWhereInput = {
    AND?: EmpleadaRolScalarWhereInput | EmpleadaRolScalarWhereInput[]
    OR?: EmpleadaRolScalarWhereInput[]
    NOT?: EmpleadaRolScalarWhereInput | EmpleadaRolScalarWhereInput[]
    id?: StringFilter<"EmpleadaRol"> | string
    empleadaId?: StringFilter<"EmpleadaRol"> | string
    rol?: EnumRolEmpleadaFilter<"EmpleadaRol"> | $Enums.RolEmpleada
  }

  export type EventoUpsertWithWhereUniqueWithoutPlannerInput = {
    where: EventoWhereUniqueInput
    update: XOR<EventoUpdateWithoutPlannerInput, EventoUncheckedUpdateWithoutPlannerInput>
    create: XOR<EventoCreateWithoutPlannerInput, EventoUncheckedCreateWithoutPlannerInput>
  }

  export type EventoUpdateWithWhereUniqueWithoutPlannerInput = {
    where: EventoWhereUniqueInput
    data: XOR<EventoUpdateWithoutPlannerInput, EventoUncheckedUpdateWithoutPlannerInput>
  }

  export type EventoUpdateManyWithWhereWithoutPlannerInput = {
    where: EventoScalarWhereInput
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyWithoutPlannerInput>
  }

  export type EmpleadaCreateWithoutRolesInput = {
    id?: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
    eventos?: EventoCreateNestedManyWithoutPlannerInput
  }

  export type EmpleadaUncheckedCreateWithoutRolesInput = {
    id?: string
    nombre: string
    apellido: string
    dni: string
    email: string
    telefono: string
    eventos?: EventoUncheckedCreateNestedManyWithoutPlannerInput
  }

  export type EmpleadaCreateOrConnectWithoutRolesInput = {
    where: EmpleadaWhereUniqueInput
    create: XOR<EmpleadaCreateWithoutRolesInput, EmpleadaUncheckedCreateWithoutRolesInput>
  }

  export type EmpleadaUpsertWithoutRolesInput = {
    update: XOR<EmpleadaUpdateWithoutRolesInput, EmpleadaUncheckedUpdateWithoutRolesInput>
    create: XOR<EmpleadaCreateWithoutRolesInput, EmpleadaUncheckedCreateWithoutRolesInput>
    where?: EmpleadaWhereInput
  }

  export type EmpleadaUpdateToOneWithWhereWithoutRolesInput = {
    where?: EmpleadaWhereInput
    data: XOR<EmpleadaUpdateWithoutRolesInput, EmpleadaUncheckedUpdateWithoutRolesInput>
  }

  export type EmpleadaUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    eventos?: EventoUpdateManyWithoutPlannerNestedInput
  }

  export type EmpleadaUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    dni?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    eventos?: EventoUncheckedUpdateManyWithoutPlannerNestedInput
  }

  export type CatMovCreateWithoutMovimientosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    subcategorias?: SubcatMovimientoCreateNestedManyWithoutCatMovInput
  }

  export type CatMovUncheckedCreateWithoutMovimientosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    subcategorias?: SubcatMovimientoUncheckedCreateNestedManyWithoutCatMovInput
  }

  export type CatMovCreateOrConnectWithoutMovimientosInput = {
    where: CatMovWhereUniqueInput
    create: XOR<CatMovCreateWithoutMovimientosInput, CatMovUncheckedCreateWithoutMovimientosInput>
  }

  export type SubcatMovimientoCreateWithoutMovimientosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    catMov: CatMovCreateNestedOneWithoutSubcategoriasInput
    detalles?: DetMovCreateNestedManyWithoutSubcatMovimientoInput
  }

  export type SubcatMovimientoUncheckedCreateWithoutMovimientosInput = {
    id?: string
    catMovId: string
    nombre: string
    descripcion?: string | null
    detalles?: DetMovUncheckedCreateNestedManyWithoutSubcatMovimientoInput
  }

  export type SubcatMovimientoCreateOrConnectWithoutMovimientosInput = {
    where: SubcatMovimientoWhereUniqueInput
    create: XOR<SubcatMovimientoCreateWithoutMovimientosInput, SubcatMovimientoUncheckedCreateWithoutMovimientosInput>
  }

  export type DetMovCreateWithoutMovimientosInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    subcatMovimiento: SubcatMovimientoCreateNestedOneWithoutDetallesInput
  }

  export type DetMovUncheckedCreateWithoutMovimientosInput = {
    id?: string
    subcatMovimientoId: string
    nombre: string
    descripcion?: string | null
  }

  export type DetMovCreateOrConnectWithoutMovimientosInput = {
    where: DetMovWhereUniqueInput
    create: XOR<DetMovCreateWithoutMovimientosInput, DetMovUncheckedCreateWithoutMovimientosInput>
  }

  export type CatMovUpsertWithoutMovimientosInput = {
    update: XOR<CatMovUpdateWithoutMovimientosInput, CatMovUncheckedUpdateWithoutMovimientosInput>
    create: XOR<CatMovCreateWithoutMovimientosInput, CatMovUncheckedCreateWithoutMovimientosInput>
    where?: CatMovWhereInput
  }

  export type CatMovUpdateToOneWithWhereWithoutMovimientosInput = {
    where?: CatMovWhereInput
    data: XOR<CatMovUpdateWithoutMovimientosInput, CatMovUncheckedUpdateWithoutMovimientosInput>
  }

  export type CatMovUpdateWithoutMovimientosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    subcategorias?: SubcatMovimientoUpdateManyWithoutCatMovNestedInput
  }

  export type CatMovUncheckedUpdateWithoutMovimientosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    subcategorias?: SubcatMovimientoUncheckedUpdateManyWithoutCatMovNestedInput
  }

  export type SubcatMovimientoUpsertWithoutMovimientosInput = {
    update: XOR<SubcatMovimientoUpdateWithoutMovimientosInput, SubcatMovimientoUncheckedUpdateWithoutMovimientosInput>
    create: XOR<SubcatMovimientoCreateWithoutMovimientosInput, SubcatMovimientoUncheckedCreateWithoutMovimientosInput>
    where?: SubcatMovimientoWhereInput
  }

  export type SubcatMovimientoUpdateToOneWithWhereWithoutMovimientosInput = {
    where?: SubcatMovimientoWhereInput
    data: XOR<SubcatMovimientoUpdateWithoutMovimientosInput, SubcatMovimientoUncheckedUpdateWithoutMovimientosInput>
  }

  export type SubcatMovimientoUpdateWithoutMovimientosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    catMov?: CatMovUpdateOneRequiredWithoutSubcategoriasNestedInput
    detalles?: DetMovUpdateManyWithoutSubcatMovimientoNestedInput
  }

  export type SubcatMovimientoUncheckedUpdateWithoutMovimientosInput = {
    id?: StringFieldUpdateOperationsInput | string
    catMovId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    detalles?: DetMovUncheckedUpdateManyWithoutSubcatMovimientoNestedInput
  }

  export type DetMovUpsertWithoutMovimientosInput = {
    update: XOR<DetMovUpdateWithoutMovimientosInput, DetMovUncheckedUpdateWithoutMovimientosInput>
    create: XOR<DetMovCreateWithoutMovimientosInput, DetMovUncheckedCreateWithoutMovimientosInput>
    where?: DetMovWhereInput
  }

  export type DetMovUpdateToOneWithWhereWithoutMovimientosInput = {
    where?: DetMovWhereInput
    data: XOR<DetMovUpdateWithoutMovimientosInput, DetMovUncheckedUpdateWithoutMovimientosInput>
  }

  export type DetMovUpdateWithoutMovimientosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    subcatMovimiento?: SubcatMovimientoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type DetMovUncheckedUpdateWithoutMovimientosInput = {
    id?: StringFieldUpdateOperationsInput | string
    subcatMovimientoId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MovimientoCreateWithoutCategoriaInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
    subcategoria: SubcatMovimientoCreateNestedOneWithoutMovimientosInput
    detalle: DetMovCreateNestedOneWithoutMovimientosInput
  }

  export type MovimientoUncheckedCreateWithoutCategoriaInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    subcategoriaId: string
    detalleId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type MovimientoCreateOrConnectWithoutCategoriaInput = {
    where: MovimientoWhereUniqueInput
    create: XOR<MovimientoCreateWithoutCategoriaInput, MovimientoUncheckedCreateWithoutCategoriaInput>
  }

  export type MovimientoCreateManyCategoriaInputEnvelope = {
    data: MovimientoCreateManyCategoriaInput | MovimientoCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type SubcatMovimientoCreateWithoutCatMovInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoCreateNestedManyWithoutSubcategoriaInput
    detalles?: DetMovCreateNestedManyWithoutSubcatMovimientoInput
  }

  export type SubcatMovimientoUncheckedCreateWithoutCatMovInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoUncheckedCreateNestedManyWithoutSubcategoriaInput
    detalles?: DetMovUncheckedCreateNestedManyWithoutSubcatMovimientoInput
  }

  export type SubcatMovimientoCreateOrConnectWithoutCatMovInput = {
    where: SubcatMovimientoWhereUniqueInput
    create: XOR<SubcatMovimientoCreateWithoutCatMovInput, SubcatMovimientoUncheckedCreateWithoutCatMovInput>
  }

  export type SubcatMovimientoCreateManyCatMovInputEnvelope = {
    data: SubcatMovimientoCreateManyCatMovInput | SubcatMovimientoCreateManyCatMovInput[]
    skipDuplicates?: boolean
  }

  export type MovimientoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: MovimientoWhereUniqueInput
    update: XOR<MovimientoUpdateWithoutCategoriaInput, MovimientoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<MovimientoCreateWithoutCategoriaInput, MovimientoUncheckedCreateWithoutCategoriaInput>
  }

  export type MovimientoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: MovimientoWhereUniqueInput
    data: XOR<MovimientoUpdateWithoutCategoriaInput, MovimientoUncheckedUpdateWithoutCategoriaInput>
  }

  export type MovimientoUpdateManyWithWhereWithoutCategoriaInput = {
    where: MovimientoScalarWhereInput
    data: XOR<MovimientoUpdateManyMutationInput, MovimientoUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type MovimientoScalarWhereInput = {
    AND?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
    OR?: MovimientoScalarWhereInput[]
    NOT?: MovimientoScalarWhereInput | MovimientoScalarWhereInput[]
    id?: StringFilter<"Movimiento"> | string
    monto?: FloatFilter<"Movimiento"> | number
    moneda?: EnumMonedaFilter<"Movimiento"> | $Enums.Moneda
    categoriaId?: StringFilter<"Movimiento"> | string
    subcategoriaId?: StringFilter<"Movimiento"> | string
    detalleId?: StringFilter<"Movimiento"> | string
    ingreso?: BoolFilter<"Movimiento"> | boolean
    fechaProgramado?: DateTimeFilter<"Movimiento"> | Date | string
    fechaRecibido?: DateTimeNullableFilter<"Movimiento"> | Date | string | null
  }

  export type SubcatMovimientoUpsertWithWhereUniqueWithoutCatMovInput = {
    where: SubcatMovimientoWhereUniqueInput
    update: XOR<SubcatMovimientoUpdateWithoutCatMovInput, SubcatMovimientoUncheckedUpdateWithoutCatMovInput>
    create: XOR<SubcatMovimientoCreateWithoutCatMovInput, SubcatMovimientoUncheckedCreateWithoutCatMovInput>
  }

  export type SubcatMovimientoUpdateWithWhereUniqueWithoutCatMovInput = {
    where: SubcatMovimientoWhereUniqueInput
    data: XOR<SubcatMovimientoUpdateWithoutCatMovInput, SubcatMovimientoUncheckedUpdateWithoutCatMovInput>
  }

  export type SubcatMovimientoUpdateManyWithWhereWithoutCatMovInput = {
    where: SubcatMovimientoScalarWhereInput
    data: XOR<SubcatMovimientoUpdateManyMutationInput, SubcatMovimientoUncheckedUpdateManyWithoutCatMovInput>
  }

  export type SubcatMovimientoScalarWhereInput = {
    AND?: SubcatMovimientoScalarWhereInput | SubcatMovimientoScalarWhereInput[]
    OR?: SubcatMovimientoScalarWhereInput[]
    NOT?: SubcatMovimientoScalarWhereInput | SubcatMovimientoScalarWhereInput[]
    id?: StringFilter<"SubcatMovimiento"> | string
    catMovId?: StringFilter<"SubcatMovimiento"> | string
    nombre?: StringFilter<"SubcatMovimiento"> | string
    descripcion?: StringNullableFilter<"SubcatMovimiento"> | string | null
  }

  export type CatMovCreateWithoutSubcategoriasInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoCreateNestedManyWithoutCategoriaInput
  }

  export type CatMovUncheckedCreateWithoutSubcategoriasInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CatMovCreateOrConnectWithoutSubcategoriasInput = {
    where: CatMovWhereUniqueInput
    create: XOR<CatMovCreateWithoutSubcategoriasInput, CatMovUncheckedCreateWithoutSubcategoriasInput>
  }

  export type MovimientoCreateWithoutSubcategoriaInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
    categoria: CatMovCreateNestedOneWithoutMovimientosInput
    detalle: DetMovCreateNestedOneWithoutMovimientosInput
  }

  export type MovimientoUncheckedCreateWithoutSubcategoriaInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    categoriaId: string
    detalleId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type MovimientoCreateOrConnectWithoutSubcategoriaInput = {
    where: MovimientoWhereUniqueInput
    create: XOR<MovimientoCreateWithoutSubcategoriaInput, MovimientoUncheckedCreateWithoutSubcategoriaInput>
  }

  export type MovimientoCreateManySubcategoriaInputEnvelope = {
    data: MovimientoCreateManySubcategoriaInput | MovimientoCreateManySubcategoriaInput[]
    skipDuplicates?: boolean
  }

  export type DetMovCreateWithoutSubcatMovimientoInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoCreateNestedManyWithoutDetalleInput
  }

  export type DetMovUncheckedCreateWithoutSubcatMovimientoInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoUncheckedCreateNestedManyWithoutDetalleInput
  }

  export type DetMovCreateOrConnectWithoutSubcatMovimientoInput = {
    where: DetMovWhereUniqueInput
    create: XOR<DetMovCreateWithoutSubcatMovimientoInput, DetMovUncheckedCreateWithoutSubcatMovimientoInput>
  }

  export type DetMovCreateManySubcatMovimientoInputEnvelope = {
    data: DetMovCreateManySubcatMovimientoInput | DetMovCreateManySubcatMovimientoInput[]
    skipDuplicates?: boolean
  }

  export type CatMovUpsertWithoutSubcategoriasInput = {
    update: XOR<CatMovUpdateWithoutSubcategoriasInput, CatMovUncheckedUpdateWithoutSubcategoriasInput>
    create: XOR<CatMovCreateWithoutSubcategoriasInput, CatMovUncheckedCreateWithoutSubcategoriasInput>
    where?: CatMovWhereInput
  }

  export type CatMovUpdateToOneWithWhereWithoutSubcategoriasInput = {
    where?: CatMovWhereInput
    data: XOR<CatMovUpdateWithoutSubcategoriasInput, CatMovUncheckedUpdateWithoutSubcategoriasInput>
  }

  export type CatMovUpdateWithoutSubcategoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUpdateManyWithoutCategoriaNestedInput
  }

  export type CatMovUncheckedUpdateWithoutSubcategoriasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type MovimientoUpsertWithWhereUniqueWithoutSubcategoriaInput = {
    where: MovimientoWhereUniqueInput
    update: XOR<MovimientoUpdateWithoutSubcategoriaInput, MovimientoUncheckedUpdateWithoutSubcategoriaInput>
    create: XOR<MovimientoCreateWithoutSubcategoriaInput, MovimientoUncheckedCreateWithoutSubcategoriaInput>
  }

  export type MovimientoUpdateWithWhereUniqueWithoutSubcategoriaInput = {
    where: MovimientoWhereUniqueInput
    data: XOR<MovimientoUpdateWithoutSubcategoriaInput, MovimientoUncheckedUpdateWithoutSubcategoriaInput>
  }

  export type MovimientoUpdateManyWithWhereWithoutSubcategoriaInput = {
    where: MovimientoScalarWhereInput
    data: XOR<MovimientoUpdateManyMutationInput, MovimientoUncheckedUpdateManyWithoutSubcategoriaInput>
  }

  export type DetMovUpsertWithWhereUniqueWithoutSubcatMovimientoInput = {
    where: DetMovWhereUniqueInput
    update: XOR<DetMovUpdateWithoutSubcatMovimientoInput, DetMovUncheckedUpdateWithoutSubcatMovimientoInput>
    create: XOR<DetMovCreateWithoutSubcatMovimientoInput, DetMovUncheckedCreateWithoutSubcatMovimientoInput>
  }

  export type DetMovUpdateWithWhereUniqueWithoutSubcatMovimientoInput = {
    where: DetMovWhereUniqueInput
    data: XOR<DetMovUpdateWithoutSubcatMovimientoInput, DetMovUncheckedUpdateWithoutSubcatMovimientoInput>
  }

  export type DetMovUpdateManyWithWhereWithoutSubcatMovimientoInput = {
    where: DetMovScalarWhereInput
    data: XOR<DetMovUpdateManyMutationInput, DetMovUncheckedUpdateManyWithoutSubcatMovimientoInput>
  }

  export type DetMovScalarWhereInput = {
    AND?: DetMovScalarWhereInput | DetMovScalarWhereInput[]
    OR?: DetMovScalarWhereInput[]
    NOT?: DetMovScalarWhereInput | DetMovScalarWhereInput[]
    id?: StringFilter<"DetMov"> | string
    subcatMovimientoId?: StringFilter<"DetMov"> | string
    nombre?: StringFilter<"DetMov"> | string
    descripcion?: StringNullableFilter<"DetMov"> | string | null
  }

  export type SubcatMovimientoCreateWithoutDetallesInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    catMov: CatMovCreateNestedOneWithoutSubcategoriasInput
    movimientos?: MovimientoCreateNestedManyWithoutSubcategoriaInput
  }

  export type SubcatMovimientoUncheckedCreateWithoutDetallesInput = {
    id?: string
    catMovId: string
    nombre: string
    descripcion?: string | null
    movimientos?: MovimientoUncheckedCreateNestedManyWithoutSubcategoriaInput
  }

  export type SubcatMovimientoCreateOrConnectWithoutDetallesInput = {
    where: SubcatMovimientoWhereUniqueInput
    create: XOR<SubcatMovimientoCreateWithoutDetallesInput, SubcatMovimientoUncheckedCreateWithoutDetallesInput>
  }

  export type MovimientoCreateWithoutDetalleInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
    categoria: CatMovCreateNestedOneWithoutMovimientosInput
    subcategoria: SubcatMovimientoCreateNestedOneWithoutMovimientosInput
  }

  export type MovimientoUncheckedCreateWithoutDetalleInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    categoriaId: string
    subcategoriaId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type MovimientoCreateOrConnectWithoutDetalleInput = {
    where: MovimientoWhereUniqueInput
    create: XOR<MovimientoCreateWithoutDetalleInput, MovimientoUncheckedCreateWithoutDetalleInput>
  }

  export type MovimientoCreateManyDetalleInputEnvelope = {
    data: MovimientoCreateManyDetalleInput | MovimientoCreateManyDetalleInput[]
    skipDuplicates?: boolean
  }

  export type SubcatMovimientoUpsertWithoutDetallesInput = {
    update: XOR<SubcatMovimientoUpdateWithoutDetallesInput, SubcatMovimientoUncheckedUpdateWithoutDetallesInput>
    create: XOR<SubcatMovimientoCreateWithoutDetallesInput, SubcatMovimientoUncheckedCreateWithoutDetallesInput>
    where?: SubcatMovimientoWhereInput
  }

  export type SubcatMovimientoUpdateToOneWithWhereWithoutDetallesInput = {
    where?: SubcatMovimientoWhereInput
    data: XOR<SubcatMovimientoUpdateWithoutDetallesInput, SubcatMovimientoUncheckedUpdateWithoutDetallesInput>
  }

  export type SubcatMovimientoUpdateWithoutDetallesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    catMov?: CatMovUpdateOneRequiredWithoutSubcategoriasNestedInput
    movimientos?: MovimientoUpdateManyWithoutSubcategoriaNestedInput
  }

  export type SubcatMovimientoUncheckedUpdateWithoutDetallesInput = {
    id?: StringFieldUpdateOperationsInput | string
    catMovId?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUncheckedUpdateManyWithoutSubcategoriaNestedInput
  }

  export type MovimientoUpsertWithWhereUniqueWithoutDetalleInput = {
    where: MovimientoWhereUniqueInput
    update: XOR<MovimientoUpdateWithoutDetalleInput, MovimientoUncheckedUpdateWithoutDetalleInput>
    create: XOR<MovimientoCreateWithoutDetalleInput, MovimientoUncheckedCreateWithoutDetalleInput>
  }

  export type MovimientoUpdateWithWhereUniqueWithoutDetalleInput = {
    where: MovimientoWhereUniqueInput
    data: XOR<MovimientoUpdateWithoutDetalleInput, MovimientoUncheckedUpdateWithoutDetalleInput>
  }

  export type MovimientoUpdateManyWithWhereWithoutDetalleInput = {
    where: MovimientoScalarWhereInput
    data: XOR<MovimientoUpdateManyMutationInput, MovimientoUncheckedUpdateManyWithoutDetalleInput>
  }

  export type PersonaCreateManyClienteInput = {
    id?: string
    nombre: string
    apellido: string
    telefono?: string | null
    email?: string | null
    cumpleanos?: Date | string | null
    eventoCalendarioId?: string | null
  }

  export type EventoCreateManyClienteInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    tipoEventoId: string
    carpetaId?: string | null
    estado: string
    plannerId: string
  }

  export type PersonaUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cumpleanos?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventoCalendarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cumpleanos?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventoCalendarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cumpleanos?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventoCalendarioId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventoUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    tipoEvento?: TipoEventoUpdateOneRequiredWithoutEventosNestedInput
    planner?: EmpleadaUpdateOneRequiredWithoutEventosNestedInput
  }

  export type EventoUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    tipoEventoId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
  }

  export type EventoUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    tipoEventoId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
  }

  export type ClienteCreateManyCiudadInput = {
    id?: string
    nombre: string
    email: string
  }

  export type ClienteUpdateWithoutCiudadInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    personas?: PersonaUpdateManyWithoutClienteNestedInput
    eventos?: EventoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutCiudadInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    personas?: PersonaUncheckedUpdateManyWithoutClienteNestedInput
    eventos?: EventoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateManyWithoutCiudadInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
  }

  export type EventoCreateManyTipoEventoInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    clienteId: string
    carpetaId?: string | null
    estado: string
    plannerId: string
  }

  export type EventoUpdateWithoutTipoEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    cliente?: ClienteUpdateOneRequiredWithoutEventosNestedInput
    planner?: EmpleadaUpdateOneRequiredWithoutEventosNestedInput
  }

  export type EventoUncheckedUpdateWithoutTipoEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    clienteId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
  }

  export type EventoUncheckedUpdateManyWithoutTipoEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    clienteId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
  }

  export type EmpleadaRolCreateManyEmpleadaInput = {
    id?: string
    rol: $Enums.RolEmpleada
  }

  export type EventoCreateManyPlannerInput = {
    id?: string
    fecha: Date | string
    numInvitados: number
    tipoEventoId: string
    clienteId: string
    carpetaId?: string | null
    estado: string
  }

  export type EmpleadaRolUpdateWithoutEmpleadaInput = {
    id?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolEmpleadaFieldUpdateOperationsInput | $Enums.RolEmpleada
  }

  export type EmpleadaRolUncheckedUpdateWithoutEmpleadaInput = {
    id?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolEmpleadaFieldUpdateOperationsInput | $Enums.RolEmpleada
  }

  export type EmpleadaRolUncheckedUpdateManyWithoutEmpleadaInput = {
    id?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolEmpleadaFieldUpdateOperationsInput | $Enums.RolEmpleada
  }

  export type EventoUpdateWithoutPlannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    tipoEvento?: TipoEventoUpdateOneRequiredWithoutEventosNestedInput
    cliente?: ClienteUpdateOneRequiredWithoutEventosNestedInput
  }

  export type EventoUncheckedUpdateWithoutPlannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    tipoEventoId?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type EventoUncheckedUpdateManyWithoutPlannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    numInvitados?: IntFieldUpdateOperationsInput | number
    tipoEventoId?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    carpetaId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type MovimientoCreateManyCategoriaInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    subcategoriaId: string
    detalleId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type SubcatMovimientoCreateManyCatMovInput = {
    id?: string
    nombre: string
    descripcion?: string | null
  }

  export type MovimientoUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subcategoria?: SubcatMovimientoUpdateOneRequiredWithoutMovimientosNestedInput
    detalle?: DetMovUpdateOneRequiredWithoutMovimientosNestedInput
  }

  export type MovimientoUncheckedUpdateWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    subcategoriaId?: StringFieldUpdateOperationsInput | string
    detalleId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MovimientoUncheckedUpdateManyWithoutCategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    subcategoriaId?: StringFieldUpdateOperationsInput | string
    detalleId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubcatMovimientoUpdateWithoutCatMovInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUpdateManyWithoutSubcategoriaNestedInput
    detalles?: DetMovUpdateManyWithoutSubcatMovimientoNestedInput
  }

  export type SubcatMovimientoUncheckedUpdateWithoutCatMovInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUncheckedUpdateManyWithoutSubcategoriaNestedInput
    detalles?: DetMovUncheckedUpdateManyWithoutSubcatMovimientoNestedInput
  }

  export type SubcatMovimientoUncheckedUpdateManyWithoutCatMovInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MovimientoCreateManySubcategoriaInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    categoriaId: string
    detalleId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type DetMovCreateManySubcatMovimientoInput = {
    id?: string
    nombre: string
    descripcion?: string | null
  }

  export type MovimientoUpdateWithoutSubcategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoria?: CatMovUpdateOneRequiredWithoutMovimientosNestedInput
    detalle?: DetMovUpdateOneRequiredWithoutMovimientosNestedInput
  }

  export type MovimientoUncheckedUpdateWithoutSubcategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    categoriaId?: StringFieldUpdateOperationsInput | string
    detalleId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MovimientoUncheckedUpdateManyWithoutSubcategoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    categoriaId?: StringFieldUpdateOperationsInput | string
    detalleId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DetMovUpdateWithoutSubcatMovimientoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUpdateManyWithoutDetalleNestedInput
  }

  export type DetMovUncheckedUpdateWithoutSubcatMovimientoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    movimientos?: MovimientoUncheckedUpdateManyWithoutDetalleNestedInput
  }

  export type DetMovUncheckedUpdateManyWithoutSubcatMovimientoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MovimientoCreateManyDetalleInput = {
    id?: string
    monto: number
    moneda: $Enums.Moneda
    categoriaId: string
    subcategoriaId: string
    ingreso: boolean
    fechaProgramado: Date | string
    fechaRecibido?: Date | string | null
  }

  export type MovimientoUpdateWithoutDetalleInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoria?: CatMovUpdateOneRequiredWithoutMovimientosNestedInput
    subcategoria?: SubcatMovimientoUpdateOneRequiredWithoutMovimientosNestedInput
  }

  export type MovimientoUncheckedUpdateWithoutDetalleInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    categoriaId?: StringFieldUpdateOperationsInput | string
    subcategoriaId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MovimientoUncheckedUpdateManyWithoutDetalleInput = {
    id?: StringFieldUpdateOperationsInput | string
    monto?: FloatFieldUpdateOperationsInput | number
    moneda?: EnumMonedaFieldUpdateOperationsInput | $Enums.Moneda
    categoriaId?: StringFieldUpdateOperationsInput | string
    subcategoriaId?: StringFieldUpdateOperationsInput | string
    ingreso?: BoolFieldUpdateOperationsInput | boolean
    fechaProgramado?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaRecibido?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CiudadCountOutputTypeDefaultArgs instead
     */
    export type CiudadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CiudadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoEventoCountOutputTypeDefaultArgs instead
     */
    export type TipoEventoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipoEventoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpleadaCountOutputTypeDefaultArgs instead
     */
    export type EmpleadaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpleadaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatMovCountOutputTypeDefaultArgs instead
     */
    export type CatMovCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatMovCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubcatMovimientoCountOutputTypeDefaultArgs instead
     */
    export type SubcatMovimientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubcatMovimientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetMovCountOutputTypeDefaultArgs instead
     */
    export type DetMovCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetMovCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonaDefaultArgs instead
     */
    export type PersonaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CiudadDefaultArgs instead
     */
    export type CiudadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CiudadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventoDefaultArgs instead
     */
    export type EventoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TipoEventoDefaultArgs instead
     */
    export type TipoEventoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TipoEventoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpleadaDefaultArgs instead
     */
    export type EmpleadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpleadaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpleadaRolDefaultArgs instead
     */
    export type EmpleadaRolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpleadaRolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MovimientoDefaultArgs instead
     */
    export type MovimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MovimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatMovDefaultArgs instead
     */
    export type CatMovArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatMovDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubcatMovimientoDefaultArgs instead
     */
    export type SubcatMovimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubcatMovimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DetMovDefaultArgs instead
     */
    export type DetMovArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DetMovDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}